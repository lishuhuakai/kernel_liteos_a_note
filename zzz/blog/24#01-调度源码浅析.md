这篇文章简单来讲述一下 `liteos` 的调度机制.

由于时间的推进, 本系列中一些东西已经过时了.

## 结构体

在开始之前,有必要和大家梳理一下调度使用到的数据结构.

### LosTaskCB

`cpu` 调度的单位并不是进程, 而是线程,或者 `liteos` 中所提及的 `task`.

`LosTaskCB` 结构体用于描述一个 `task`,它里面有若干子结构体和调度相关:

```c
// SchedHPF 结构体用于描述进程的高优先级调度参数:
typedef struct {//记录任务调度信息
    UINT16  policy; // 所有调度策略都必须存在此字段，并且必须是结构中的第一个字段
    UINT16  basePrio; // 起始优先级
    UINT16  priority; // 当前优先级
    UINT32  initTimeSlice;// 初始化时间片
    UINT32  priBitmap; // 记录任务优先级变化的位图，优先级不能大于31
} SchedHPF;

typedef struct {
    union {
        SchedEDF edf;
        SchedHPF hpf; // 目前只支持 优先级策略（Highest-Priority-First，HPF）
    };
} SchedPolicy;
typedef struct TagTaskCB {
    // ...
    UINT16          taskStatus;   // 各种状态标签,可以拥有多种标签,按位标识
    UINT64          startTime;    // 任务开始时间
    UINT64          waitTime;     // 设置任务调度延期时间
    UINT64          irqStartTime; // 任务中断开始时间
    UINT32          irqUsedTime;  // 任务中断消耗时间
    INT32           timeSlice;    // 任务剩余时间片
    SortLinkList    sortList;     // 跟CPU捆绑的任务排序链表节点,上面挂的是就绪队列的下一个阶段,进入CPU要执行的任务队列
    const SchedOps  *ops; // 调度接口,不同的调度算法实现不同的调度接口
    SchedPolicy     sp; // 记录调度策略
	// ...
} LosTaskCB;
```

+ `SchedOps`类型的实例`ops` 用于记录调度策略.
+ `SchedOplicy` 类型的实例 `sp` 用于记录和调度策略相关的调度参数.

### SchedRunqueue

调度不仅仅是 `task` 的事情,它也和 `cpu` 息息相关.每一个 `cpu` 都有一个调度队列, `SchedRunqueue` 用于描述这个调度队列:

```c
typedef enum {
    INT_NO_RESCH = 0x0,   // 无需调度
    INT_PEND_RESCH = 0x1, // 因阻塞而引起的调度
    INT_PEND_TICK = 0x2,  // 因Tick而引起的调度
} SchedFlag;

typedef struct {
    SortLinkAttribute timeoutQueue; // task超时队列
    HPFRunqueue       *hpfRunqueue; // 高优先级优先的运行队列
    EDFRunqueue       *edfRunqueue; // 截止时间优先的运行队列
    UINT64            responseTime; /* Response time for current CPU tick interrupts */
    UINT32            responseID;   /* The response ID of the current CPU tick interrupt */
    LosTaskCB         *idleTask;   /* idle task id */
    UINT32            taskLockCnt;  /* task lock flag */
    UINT32            schedFlag;    /* pending scheduler flag */
} SchedRunqueue;
extern SchedRunqueue g_schedRunqueue[LOSCFG_KERNEL_CORE_NUM]; //每个CPU核都有一个属于自己的调度队列
```

这个总结构体里面有两个很重要的子结构:

```c
/*!
 * earliest deadline first，EDF
 * 调度运行队列
 */
typedef struct {
    LOS_DL_LIST root;
    LOS_DL_LIST waitList;
    UINT64 period;
} EDFRunqueue;

/*!
 * High Priority First 高优先级优先
 */
#define OS_PRIORITY_QUEUE_NUM 32 //队列优先级
typedef struct {
    LOS_DL_LIST priQueList[OS_PRIORITY_QUEUE_NUM];	//任务挂载这个链表上
    UINT32      readyTasks[OS_PRIORITY_QUEUE_NUM];  //已就绪任务的个数
    UINT32      queueBitmap;	//位图
} HPFQueue;

typedef struct {
    HPFQueue queueList[OS_PRIORITY_QUEUE_NUM]; // 每一个优先级都有一个队列
    UINT32   queueBitmap; // 位图
} HPFRunqueue;
```

### TSK_INIT_PARAM_S

`task` 在初始化的时候,可以指定初始化参数, 初始化参数对应的结构为`TASK_INIT_PARAM_S`:

```c
/**
 * @ingroup los_task
 * Define the structure of the parameters used for task creation.
 *
 * Information of specified parameters passed in during task creation.
 */
typedef struct tagTskInitParam {//Task的初始化参数
    TSK_ENTRY_FUNC  pfnTaskEntry;  /**< Task entrance function | 任务的入口函数*/
    UINT16          usTaskPrio;    /**< Task priority | 任务优先级*/
    UINT16          policy;        /**< Task policy | 任务调度方式*/
    UINTPTR         auwArgs[4];    /**< Task parameters, of which the maximum number is four | 入口函数的参数,最多四个 */
    UINT32          uwStackSize;   /**< Task stack size | 栈大小*/
    CHAR            *pcName;       /**< Task name | 任务名称*/
#ifdef LOSCFG_KERNEL_SMP
    UINT16          usCpuAffiMask; /**< Task cpu affinity mask | 任务cpu亲和力掩码 */
#endif
    UINT32          uwResved;      /**< It is automatically deleted if set to LOS_TASK_STATUS_DETACHED.
                                        It is unable to be deleted if set to 0. | 如果设置为LOS_TASK_STATUS_DETACHED，
                                        则自动删除.如果设置为0，则无法删除 */
    UINT16          consoleID;     /**< The console id of task belongs  | 任务的控制台id所属*/
    UINTPTR          processID;	///< 进程ID
    UserTaskParam   userParam;	///< 任务用户态运行时任何参数
    /* edf parameters */
    UINT32          runTimeUs;
    UINT64          deadlineUs;
    UINT64          periodUs;
} TSK_INIT_PARAM_S;
```

### SchedOps

内核有不同的调度策略,为了屏蔽底层的调度算法, 内核抽象出了一个调度接口 `SchedOps`, 每种不同的调度策略都需要实现这个接口:

```c
typedef struct {//调度接口函数
    VOID (*dequeue)(SchedRunqueue *rq, LosTaskCB *taskCB); 	///< 出队列
    VOID (*enqueue)(SchedRunqueue *rq, LosTaskCB *taskCB); 	///< 入队列
    VOID (*start)(SchedRunqueue *rq, LosTaskCB *taskCB); 	///< 开始执行任务
    VOID (*exit)(LosTaskCB *taskCB);	///< 任务退出
    UINT64 (*waitTimeGet)(LosTaskCB *taskCB);
    UINT32 (*wait)(LosTaskCB *runTask, LOS_DL_LIST *list, UINT32 timeout); ///< 任务等待
    VOID (*wake)(LosTaskCB *taskCB);///< 任务唤醒
    BOOL (*schedParamModify)(LosTaskCB *taskCB, const SchedParam *param);///< 修改调度参数
    UINT32 (*schedParamGet)(const LosTaskCB *taskCB, SchedParam *param);///< 获取调度参数
    UINT32 (*delay)(LosTaskCB *taskCB, UINT64 waitTime);///< 延时执行
    VOID (*yield)(LosTaskCB *taskCB);///< 让出控制权
    UINT32 (*suspend)(LosTaskCB *taskCB);///< 挂起任务
    UINT32 (*resume)(LosTaskCB *taskCB, BOOL *needSched);///< 恢复任务
    UINT64 (*deadlineGet)(const LosTaskCB *taskCB);///< 获取最后期限
    VOID (*timeSliceUpdate)(SchedRunqueue *rq, LosTaskCB *taskCB, UINT64 currTime);///< 更新时间片
    INT32 (*schedParamCompare)(const SchedPolicy *sp1, const SchedPolicy *sp2); ///< 比较调度参数
    VOID (*priorityInheritance)(LosTaskCB *owner, const SchedParam *param);//继承调度参数
    VOID (*priorityRestore)(LosTaskCB *owner, const LOS_DL_LIST *list, const SchedParam *param);///< 恢复调度参数
} SchedOps;
```

在下文之中,我们将以 `HPF` 调度算法为例,简单来讲解一下 `liteos` 的调度策略.

对于高优先级优先调度算法而言,它的接口实现如下:

```c
/*!
 * 优先级调度算法操作
 */
const STATIC SchedOps g_priorityOps = {
    .dequeue = HPFDequeue,
    .enqueue = HPFEnqueue,
    .waitTimeGet = HPFWaitTimeGet,
    .wait = HPFWait,
    .wake = HPFWake,
    .schedParamModify = HPFSchedParamModify,
    .schedParamGet = HPFSchedParamGet,
    .delay = HPFDelay,
    .yield = HPFYield,
    .start = HPFStartToRun,
    .exit = HPFExit,
    .suspend = HPFSuspend,
    .resume = HPFResume,
    .deadlineGet = HPFTimeSliceGet,
    .timeSliceUpdate = HPFTimeSliceUpdate,
    .schedParamCompare = HPFParamCompare,
    .priorityInheritance = HPFPriorityInheritance,
    .priorityRestore = HPFPriorityRestore,
};
```

## task初始化

内核会调用 `TackCBInit` 来初始化 `task`, 用户指定的参数会放入结构体 `TSK_INIT_PARAM_S`, 传递给该函数, 这个结构体包含了 `task` 应当使用的调度算法.

```c
/*!
 * 初始化高优先级调度策略
 */
VOID HPFTaskSchedParamInit(LosTaskCB *taskCB, UINT16 policy,
                           const SchedParam *parentParam,
                           const LosSchedParam *param)
{
    SchedHPF *sched = (SchedHPF *)&taskCB->sp;
    sched->policy = policy;
    if (param != NULL) {
        sched->priority = param->priority;
    } else {
        sched->priority = parentParam->priority; // 记录下优先级
    }
    sched->basePrio = parentParam->basePrio;
    sched->initTimeSlice = 0;
    taskCB->timeSlice = sched->initTimeSlice;
    taskCB->ops = &g_priorityOps;
}

UINT32 OsSchedParamInit(LosTaskCB *taskCB, UINT16 policy, const SchedParam *parentParam, const LosSchedParam *param)
{
    switch (policy) {
        case LOS_SCHED_FIFO:
        case LOS_SCHED_RR:
            HPFTaskSchedParamInit(taskCB, policy, parentParam, param);
            break;
        // ...
        default:
            return LOS_NOK;
    }
    return LOS_OK;
}

/*!
 * task初始化
 */
STATIC UINT32 TaskCBInit(LosTaskCB *taskCB, const TSK_INIT_PARAM_S *initParam)
{
    UINT32 ret;
    UINT32 numCount;
    SchedParam schedParam = { 0 };
    LosSchedParam initSchedParam = {0};
    UINT16 policy = (initParam->policy == LOS_SCHED_NORMAL) ? LOS_SCHED_RR : initParam->policy;

    TaskCBBaseInit(taskCB, initParam);//初始化任务的基本信息,
    //taskCB->stackPointer指向内核态栈 sp位置,该位置存着 任务初始上下文

    schedParam.policy = policy; // 记录下调度策略
    OsProcessAddNewTask(initParam->processID, taskCB, &schedParam, &numCount);
    if (policy == LOS_SCHED_DEADLINE) {
        initSchedParam.runTimeUs = initParam->runTimeUs;
        initSchedParam.deadlineUs = initParam->deadlineUs;
        initSchedParam.periodUs = initParam->periodUs;
    } else {
        initSchedParam.priority = initParam->usTaskPrio;
    }
    OsSchedParamInit(taskCB, policy, &schedParam, &initSchedParam);
    // ...
    return LOS_OK;
}
```



## task加入调度队列

为了说明 `task` 调度,我这里列举一个场景,那就是父进程调用了 `fork` 之后,会产生子进程,这里分析一下,子进程是如何被调度的.

进程调用`fork` 之后,大致会有这么一个调用过程:

```python
SysFork # 系统调用
    \--> OsClone # 克隆父进程
    		\--> OsCopyProcess
    				\--> OsFOrkInitPCB # 初始化子进程控制块
    				\--> OsCopyProcessResources # 拷贝进程的资源
    				\--> OsChildSetProcessGroupAndSched # 设置进程组和加入进程调度就绪队列
                    \--> LOS_MpSchedule(OS_MP_CPU_ALL) # 给各CPU发送准备接受调度信号
                    \--> LOS_Schedule # 调度进程
```

这里具体分析一下 `OsChildSetProcessGroupAndSched`, 看一下内核是如何将子进程放入调度队列.

```c
/*!
 * 获取当前CPU的调度队列, 每一个cpu都有一个调度队列
 */
STATIC INLINE SchedRunqueue *OsSchedRunqueue(VOID)
{
    return &g_schedRunqueue[ArchCurrCpuid()];
}

/*!
 * 设置进程组和加入进程调度就绪队列
 */
STATIC UINT32 OsChildSetProcessGroupAndSched(LosProcessCB *child, LosProcessCB *run)
{
    UINT32 intSave;
    ProcessGroup *pgroup = NULL;
    SCHEDULER_LOCK(intSave);
    if ((UINTPTR)OS_GET_PGROUP_LEADER(run->pgroup) == OS_USER_PRIVILEGE_PROCESS_GROUP) {
        OsSetProcessGroupIDUnsafe(child->processID, child->processID, &pgroup);
    }
    child->processStatus &= ~OS_PROCESS_STATUS_INIT; // 子线程去掉INIT标记
    LosTaskCB *taskCB = child->threadGroup; // 主task
    taskCB->ops->enqueue(OsSchedRunqueue(), taskCB); // 将task加入就绪队列
    SCHEDULER_UNLOCK(intSave);
    (VOID)LOS_MemFree(m_aucSysMem1, pgroup);
    return LOS_OK;
}
```

对于 `HPF` 算法,实际上 `enqueue` 回调为 `HPFEnqueue` :

```c
/*!
 * @param basePrio 基础优先级
 * @param priority 优先级
 */
STATIC INLINE VOID PriQueHeadInsert(HPFRunqueue *rq, UINT32 basePrio, LOS_DL_LIST *priQue, UINT32 priority)
{
    HPFQueue *queueList = &rq->queueList[basePrio]; // 根据basePrio找到HPFQueue(基础队列)
    LOS_DL_LIST *priQueList = &queueList->priQueList[0];
    UINT32 *bitmap = &queueList->queueBitmap; // 队列位图,用于指示哪些队列不为空

    /*
     * Task control blocks are inited as zero. And when task is deleted,
     * and at the same time would be deleted from priority queue or
     * other lists, task pend node will restored as zero.
     */
    LOS_ASSERT(priQue->pstNext == NULL);

    if (*bitmap == 0) {
        rq->queueBitmap |= PRIQUEUE_PRIOR0_BIT >> basePrio;
    }

    if (LOS_ListEmpty(&priQueList[priority])) {
        *bitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
    }

    LOS_ListHeadInsert(&priQueList[priority], priQue); // 插入链表首部
    queueList->readyTasks[priority]++; // 就绪task个数+1
}

STATIC INLINE VOID PriQueInsert(HPFRunqueue *rq, LosTaskCB *taskCB)
{
    LOS_ASSERT(!(taskCB->taskStatus & OS_TASK_STATUS_READY));
    SchedHPF *sched = (SchedHPF *)&taskCB->sp; // 任务调度信息
    switch (sched->policy) {
        case LOS_SCHED_RR: { // 暂时只关注RR类型的调度
            if (taskCB->timeSlice > OS_TIME_SLICE_MIN) { // task的时间片已经耗完,将task插入末尾
                PriQueHeadInsert(rq, sched->basePrio, &taskCB->pendList, sched->priority);
            } else {
                sched->initTimeSlice = TimeSliceCalculate(rq, sched->basePrio, sched->priority);
                taskCB->timeSlice = sched->initTimeSlice;
                PriQueTailInsert(rq, sched->basePrio, &taskCB->pendList, sched->priority);
            }
            break;
        }
        // ...
    }
    taskCB->taskStatus &= ~OS_TASK_STATUS_BLOCKED;
    taskCB->taskStatus |= OS_TASK_STATUS_READY;
}

/*!
 * 将task加入优先级调度算法的就绪队列
 */
STATIC VOID HPFEnqueue(SchedRunqueue *rq, LosTaskCB *taskCB)
{
    PriQueInsert(rq->hpfRunqueue, taskCB);
}
```

## task调度

我们仍然以 `fork` 为例子,将子进程加入了就绪队列之中,内核会尝试调度子进程,也就是会执行 `LOS_Schedule` 函数:

```c
/*!
 * 任务调度
 */
VOID OsSchedResched(VOID)
{
    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
    SchedRunqueue *rq = OsSchedRunqueue(); // 获得cpu的调度队列
    rq->schedFlag &= ~INT_PEND_RESCH;
    LosTaskCB *runTask = OsCurrTaskGet();
    LosTaskCB *newTask = TopTaskGet(rq); // 获得新的task
    if (runTask == newTask) {
        return;
    }
	// task切换
    SchedTaskSwitch(rq, runTask, newTask);
}

VOID LOS_Schedule(VOID)
{
    UINT32 intSave;
    LosTaskCB *runTask = OsCurrTaskGet(); // 获得当前正在运行的task
    SchedRunqueue *rq = OsSchedRunqueue();
	// ...
    SCHEDULER_LOCK(intSave);
    runTask->ops->timeSliceUpdate(rq, runTask, OsGetCurrSchedTimeCycle()); // 更新task的时间片
    runTask->ops->enqueue(rq, runTask); // 将当前task加入就绪队列
    OsSchedResched(); // 调度另外一个新task
    SCHEDULER_UNLOCK(intSave);
}
```

调度大致分为几步,首先更新正在运行的 `task` 的调度信息,并将当前 `task` 加入就绪队列.

其次,挑选一个要调度的 `task`.

最后再进行 `task` 的切换即可.

### 保存当前task的调度信息

首先执行 `HPF` 算法的 `timeSliceUpdate` 回调 `HPFTimeSliceUpdate`, 更新当前 `task` 的调度信息.

```c
/*!
 * @param rq 调度队列
 * @param taskCB task指针
 * @param currTime 当前时间
 */
STATIC VOID HPFTimeSliceUpdate(SchedRunqueue *rq, LosTaskCB *taskCB, UINT64 currTime)
{
    SchedHPF *sched = (SchedHPF *)&taskCB->sp;
    LOS_ASSERT(currTime >= taskCB->startTime);
	// irqUsedTime 中断消耗的时间
    // startTime 任务开始时间
    INT32 incTime = (currTime - taskCB->startTime - taskCB->irqUsedTime);
    LOS_ASSERT(incTime >= 0);
    if (sched->policy == LOS_SCHED_RR) {
        taskCB->timeSlice -= incTime; // 更新剩余时间片
    }
    taskCB->irqUsedTime = 0;
    taskCB->startTime = currTime;
    if (taskCB->timeSlice <= OS_TIME_SLICE_MIN) {
        rq->schedFlag |= INT_PEND_RESCH; // 因为阻塞而引起的调度
    }
}
```

然后将当前 `task` 加入就绪队列.

### 选择要调度的task

`TopTaskGet` 用于获取一个task, 优先调度放在 `edfRunqueue` 中的task.

```c
STATIC INLINE LosTaskCB *EDFRunqueueTopTaskGet(EDFRunqueue *rq)
{
    LOS_DL_LIST *root = &rq->root;
    if (LOS_ListEmpty(root)) {
        return NULL;
    }
    return LOS_DL_LIST_ENTRY(LOS_DL_LIST_FIRST(root), LosTaskCB, pendList);
}

/*!
 * 获得一个新的待调度的任务
 */
STATIC LosTaskCB *TopTaskGet(SchedRunqueue *rq)
{
    LosTaskCB *newTask = EDFRunqueueTopTaskGet(rq->edfRunqueue); // 首先按照截止时间调度
    newTask = HPFRunqueueTopTaskGet(rq->hpfRunqueue); // 其次按照优先级调度
    newTask = rq->idleTask;
FIND:
    newTask->ops->start(rq, newTask);
    return newTask;
}
```

其次,按照 `task` 的优先级进行调度. `HPFRunqueueTopTaskGet` 的思想很简单.

```c
STATIC INLINE LosTaskCB *HPFRunqueueTopTaskGet(HPFRunqueue *rq)
{
    LosTaskCB *newTask = NULL;
    UINT32 baseBitmap = rq->queueBitmap;
#ifdef LOSCFG_KERNEL_SMP
    UINT32 cpuid = ArchCurrCpuid(); // 获得cpuid
#endif
    while (baseBitmap) {
        UINT32 basePrio = CLZ(baseBitmap);
        HPFQueue *queueList = &rq->queueList[basePrio];
        UINT32 bitmap = queueList->queueBitmap;
        while (bitmap) {
            UINT32 priority = CLZ(bitmap);
            LOS_DL_LIST_FOR_EACH_ENTRY(newTask, &queueList->priQueList[priority], LosTaskCB, pendList) {
#ifdef LOSCFG_KERNEL_SMP
                if (newTask->cpuAffiMask & (1U << cpuid)) {
#endif
                    return newTask; // 返回优先级最高的task
#ifdef LOSCFG_KERNEL_SMP
                }
#endif
            }
            bitmap &= ~(1U << (OS_PRIORITY_QUEUE_NUM - priority - 1));
        }
        baseBitmap &= ~(1U << (OS_PRIORITY_QUEUE_NUM - basePrio - 1));
    }
    return NULL;
}
```

然后, 开始运行挑选的 `task`,也就是调用调度算法的 `start` 接口.

对于 `HPF` 调度算法而言, `start` 回调为 `HPFStartToRun` :

```c
STATIC INLINE VOID PriQueDelete(HPFRunqueue *rq, UINT32 basePrio, LOS_DL_LIST *priQue, UINT32 priority)
{
    HPFQueue *queueList = &rq->queueList[basePrio];
    LOS_DL_LIST *priQueList = &queueList->priQueList[0];
    UINT32 *bitmap = &queueList->queueBitmap; // 找到位图
    LOS_ListDelete(priQue);
    queueList->readyTasks[priority]--; // 就绪task的数目-1
    if (LOS_ListEmpty(&priQueList[priority])) { // priority对应的priQueList为空,那么清除priority在bitmap上的未标记
        *bitmap &= ~(PRIQUEUE_PRIOR0_BIT >> priority); 
    }
    if (*bitmap == 0) { // bitmap为空,清除bitmap在rq->queueBitmap上的位标记
        rq->queueBitmap &= ~(PRIQUEUE_PRIOR0_BIT >> basePrio);
    }
}

/*!
 * 出就绪队列
 */
STATIC VOID HPFDequeue(SchedRunqueue *rq, LosTaskCB *taskCB)
{
    SchedHPF *sched = (SchedHPF *)&taskCB->sp;
    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {//是否有就绪状态
        PriQueDelete(rq->hpfRunqueue, sched->basePrio, &taskCB->pendList, sched->priority);
        taskCB->taskStatus &= ~OS_TASK_STATUS_READY;//更新成非就绪状态
    }
}

STATIC VOID HPFStartToRun(SchedRunqueue *rq, LosTaskCB *taskCB)
{
    HPFDequeue(rq, taskCB);
}
```
### task切换

`SchedTaskSwitch` 函数的实现在别的文章中有所涉及,这里就不再详细讲述,感兴趣的同学可以翻看本系列的相关文章.

## task等待

当 `task` 需要某种资源,但是内核又不能满足的时候, `task` 往往会陷入等待的境地, 根据等待资源的不同, `task` 等待的原因分为了如下几种:

```c
/// 任务的等待事件/信号列表
#define OS_TASK_WAIT_ANYPROCESS (1 << 0U)					///< 等待任意进程出现
#define OS_TASK_WAIT_PROCESS    (1 << 1U)					///< 等待指定进程出现
#define OS_TASK_WAIT_GID        (1 << 2U)					///< 等待组ID
#define OS_TASK_WAIT_SEM        (OS_TASK_WAIT_GID + 1)		///< 等待信号量发生
#define OS_TASK_WAIT_QUEUE      (OS_TASK_WAIT_SEM + 1)		///< 等待队列到来
#define OS_TASK_WAIT_JOIN       (OS_TASK_WAIT_QUEUE + 1)	///< 等待联结到来
#define OS_TASK_WAIT_SIGNAL     (OS_TASK_WAIT_JOIN + 1) 	///< 等待普通信号到来
#define OS_TASK_WAIT_LITEIPC    (OS_TASK_WAIT_SIGNAL + 1)	///< 等待liteipc到来
#define OS_TASK_WAIT_MUTEX      (OS_TASK_WAIT_LITEIPC + 1)	///< 等待MUTEX到来
#define OS_TASK_WAIT_FUTEX      (OS_TASK_WAIT_MUTEX + 1)	///< 等待FUTEX到来
#define OS_TASK_WAIT_EVENT      (OS_TASK_WAIT_FUTEX + 1) 	///< 等待事件发生
#define OS_TASK_WAIT_COMPLETE   (OS_TASK_WAIT_EVENT + 1)	///< 等待结束信号
```

这里举一个例子,其他的基本类似.

内核有一个外部接口 `LOS_SemPend`, `task` 调用这个接口用于获得信号量,如果 `timeout` 参数不为0, 而且内核不能及时分配资源的时候,就会让 `task` 陷入等待:

```c
/*!
 * 设置事件阻塞掩码,即设置任务的等待事件.
 */
STATIC INLINE VOID OsTaskWaitSetPendMask(UINT16 mask, UINTPTR lockID, UINT32 timeout)
{
    LosTaskCB *runTask = OsCurrTaskGet();
    runTask->waitID = lockID;
    runTask->waitFlag = mask; //当前任务在等待什么东东到来 例如: OS_TASK_WAIT_LITEIPC
}

/*!
 * 对外接口 申请指定的信号量，并设置超时时间
 */
LITE_OS_SEC_TEXT UINT32 LOS_SemPend(UINT32 semHandle, UINT32 timeout)
{
    UINT32 intSave;
    LosSemCB *semPended = GET_SEM(semHandle); // 通过ID拿到信号体
    UINT32 retErr = LOS_OK;
    LosTaskCB *runTask = NULL;
    runTask = OsCurrTaskGet();//获取当前任务
    SCHEDULER_LOCK(intSave);
	// ...
    if (semPended->semCount > 0) { //还有资源可用,返回肯定得成功,semCount=0时代表没资源了,task会必须去睡眠了
        semPended->semCount--;//资源少了一个
        goto OUT;//注意这里 retErr = LOS_OK ,所以返回是OK的 
    } else if (!timeout) {
        retErr = LOS_ERRNO_SEM_UNAVAILABLE;
        goto OUT;
    }
	// ...
    OsTaskWaitSetPendMask(OS_TASK_WAIT_SEM, semPended->semID, timeout);
    retErr = runTask->ops->wait(runTask, &semPended->semList, timeout); // task调用wait回调
    if (retErr == LOS_ERRNO_TSK_TIMEOUT) { //注意:这里是涉及到task切换的,把自己挂起,唤醒其他task 
        retErr = LOS_ERRNO_SEM_TIMEOUT;
    }

OUT:
    SCHEDULER_UNLOCK(intSave);
    return retErr;
}
```

对于 `HPF` 调度算法而言, `wait` 回调为`HPFWait`:

```c
/*!
 * task等待
 * @param list 等待链表,等待该资源的task都要放入此链表
 */
STATIC UINT32 HPFWait(LosTaskCB *runTask, LOS_DL_LIST *list, UINT32 ticks)
{
    runTask->taskStatus |= OS_TASK_STATUS_PENDING;
    LOS_ListTailInsert(list, &runTask->pendList); // 将task插入链表尾部

    if (ticks != LOS_WAIT_FOREVER) {
        runTask->taskStatus |= OS_TASK_STATUS_PEND_TIME;
        runTask->waitTime = OS_SCHED_TICK_TO_CYCLE(ticks); // 记录下等待时间
    }
    if (OsPreemptableInSched()) {
        OsSchedResched();
        if (runTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
            runTask->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
            return LOS_ERRNO_TSK_TIMEOUT;
        }
    }
    return LOS_OK;
}
```
## task唤醒

当 `task` 所申请的资源可以满足的时候,内核就会唤醒等待的 `task`. 继续以上面的场景为例, 如果有线程释放了信号量,那么它会调用 `LOS_SemPost`:

```c
/*!
 * 以不安全的方式释放指定的信号量,所谓不安全指的是不用自旋锁
 */
LITE_OS_SEC_TEXT UINT32 OsSemPostUnsafe(UINT32 semHandle, BOOL *needSched)
{
    LosTaskCB *resumedTask = NULL;
    LosSemCB *semPosted = GET_SEM(semHandle);
	// ...
    if (!LOS_ListEmpty(&semPosted->semList)) {//当前有任务挂在semList上,要去唤醒任务
        //semList上面挂的都是task->pendlist节点,取第一个task下来唤醒
        resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(semPosted->semList)));
        OsTaskWakeClearPendMask(resumedTask);
        resumedTask->ops->wake(resumedTask);
        if (needSched != NULL) {//参数不为空,就返回需要调度的标签
            *needSched = TRUE;//TRUE代表需要调度
        }
    } else {//当前没有任务挂在semList上,
        semPosted->semCount++;//信号资源多一个
    }
    return LOS_OK;
}

/*!
 * 对外接口 释放指定的信号量
 */
LITE_OS_SEC_TEXT UINT32 LOS_SemPost(UINT32 semHandle)
{
    UINT32 intSave;
    UINT32 ret;
    BOOL needSched = FALSE;
    if (GET_SEM_INDEX(semHandle) >= LOSCFG_BASE_IPC_SEM_LIMIT) {
        return LOS_ERRNO_SEM_INVALID;
    }
    SCHEDULER_LOCK(intSave);
    ret = OsSemPostUnsafe(semHandle, &needSched);
        SCHEDULER_UNLOCK(intSave);
    if (needSched) {//需要调度的情况
        LOS_MpSchedule(OS_MP_CPU_ALL);//向所有CPU发送调度指令
        LOS_Schedule();// 发起调度
    }
    return ret;
}
```

对于 `HPF` 算法而言,它对应的 `wake` 回调为 `HPFWake` :

```c
/*!
 * 将task从超时队列中移除
 */
STATIC INLINE VOID OsSchedTimeoutQueueDelete(LosTaskCB *taskCB)
{
    SortLinkList *node = &taskCB->sortList;
#ifdef LOSCFG_KERNEL_SMP
    SchedRunqueue *rq = OsSchedRunqueueByID(node->cpuid);
#else
    SchedRunqueue *rq = OsSchedRunqueueByID(0);
#endif
    UINT64 oldResponseTime = GET_SORTLIST_VALUE(node);
    OsDeleteFromSortLink(&rq->timeoutQueue, node); // 从超时队列中移除
    if (oldResponseTime <= rq->responseTime) {
        rq->responseTime = OS_SCHED_MAX_RESPONSE_TIME;
    }
}

STATIC VOID HPFWake(LosTaskCB *resumedTask)
{
    LOS_ListDelete(&resumedTask->pendList);
    resumedTask->taskStatus &= ~OS_TASK_STATUS_PENDING; // 去掉pending标记

    if (resumedTask->taskStatus & OS_TASK_STATUS_PEND_TIME) { // 如果task需要pending一段时间
        OsSchedTimeoutQueueDelete(resumedTask);
        resumedTask->taskStatus &= ~OS_TASK_STATUS_PEND_TIME;
    }
    if (!(resumedTask->taskStatus & OS_TASK_STATUS_SUSPENDED)) {
        HPFEnqueue(OsSchedRunqueue(), resumedTask); // 将task加入就绪队列
    }
}
```

## task停止

`listos` 对外提供了一个接口,用于暂停一个 `task`, 它是 `LOS_TaskSuspend`:

```c
/*!
 * 任务暂停,参数可以不是当前任务，也就是说 A任务可以让B任务处于阻塞状态,挂起指定的任务，然后切换任务
 */
LITE_OS_SEC_TEXT STATIC UINT32 OsTaskSuspend(LosTaskCB *taskCB)
{
    UINT32 errRet;
    UINT16 tempStatus = taskCB->taskStatus;
    if (tempStatus & OS_TASK_STATUS_UNUSED) {
        return LOS_ERRNO_TSK_NOT_CREATED;
    }

    if (tempStatus & OS_TASK_STATUS_SUSPENDED) {
        return LOS_ERRNO_TSK_ALREADY_SUSPENDED;
    }

    if ((tempStatus & OS_TASK_STATUS_RUNNING) && //如果参数任务正在运行，注意多Cpu core情况下，贴着正在运行标签的任务并不一定是当前CPU的执行任务，
        !OsTaskSuspendCheckOnRun(taskCB, &errRet)) {//很有可能是别的CPU core在跑的任务
        return errRet;
    }

    return taskCB->ops->suspend(taskCB);
}
```

对于 `HPF` 调度算法而言, `suspend` 回调为 `HPFSuspend`:

```c
STATIC UINT32 HPFSuspend(LosTaskCB *taskCB)
{
    if (taskCB->taskStatus & OS_TASK_STATUS_READY) { // task已经就绪
        HPFDequeue(OsSchedRunqueue(), taskCB); // 将task移出就绪队列
    }

    SchedTaskFreeze(taskCB);

    taskCB->taskStatus |= OS_TASK_STATUS_SUSPENDED; // 打上SUSPENDED标签,表示task被暂停
    OsHookCall(LOS_HOOK_TYPE_MOVEDTASKTOSUSPENDEDLIST, taskCB);
    if (taskCB == OsCurrTaskGet()) {
        OsSchedResched();
    }
    return LOS_OK;
}
```

## task继续

既然有停止接口, 自然有继续运行的接口,那就是 `LOS_TaskResume`:

```c
/*!
 * 恢复挂起的任务，使该任务进入ready状态
 */
LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskResume(UINT32 taskID)
{
    UINT32 intSave;
    UINT32 errRet;
    BOOL needSched = FALSE;
	// ...

    LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
    SCHEDULER_LOCK(intSave);

    /* clear pending signal */
    taskCB->signal &= ~SIGNAL_SUSPEND;//清除挂起信号

    if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
        errRet = LOS_ERRNO_TSK_NOT_CREATED;
        OS_GOTO_ERREND();
    } else if (!(taskCB->taskStatus & OS_TASK_STATUS_SUSPENDED)) {
        errRet = LOS_ERRNO_TSK_NOT_SUSPENDED; // 任务没有被挂起,返回错误
        OS_GOTO_ERREND();
    }
    errRet = taskCB->ops->resume(taskCB, &needSched); // 调用resume回调
    SCHEDULER_UNLOCK(intSave);
    LOS_MpSchedule(OS_MP_CPU_ALL); // 向其他cpu发起调度请求
    if (OS_SCHEDULER_ACTIVE && needSched) {
        LOS_Schedule();
    }
    return errRet;
}
```

对于 `HPF`调度算法而言, `resume`回调为 `HPFResume`:

```c
/*!
 * 判断task是否被阻塞
 */
STATIC INLINE BOOL OsTaskIsBlocked(const LosTaskCB *taskCB)
{
    return ((taskCB->taskStatus & (OS_TASK_STATUS_SUSPENDED | OS_TASK_STATUS_PENDING | OS_TASK_STATUS_DELAY)) != 0);
}

STATIC UINT32 HPFResume(LosTaskCB *taskCB, BOOL *needSched)
{
    *needSched = FALSE;
    SchedTaskUnfreeze(taskCB);
    taskCB->taskStatus &= ~OS_TASK_STATUS_SUSPENDED; // 去掉SUSPENDED标签
    if (!OsTaskIsBlocked(taskCB)) {
        HPFEnqueue(OsSchedRunqueue(), taskCB); // 将task加入就绪队列
        *needSched = TRUE;
    }
    return LOS_OK;
}
```



## task延时

`liteos` 向外提供一个接口 `LOS_TaskDelay`, 用于将 `task` 延后一段时间再继续运行:

```c
/*!
 * 任务延时等待，释放CPU，等待时间到期后该任务会重新进入ready状态
 */
LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
{
    UINT32 intSave;

    if (OS_INT_ACTIVE) {
        PRINT_ERR("In interrupt not allow delay task!\n");
        return LOS_ERRNO_TSK_DELAY_IN_INT;
    }

    LosTaskCB *runTask = OsCurrTaskGet();
    if (runTask->taskStatus & OS_TASK_FLAG_SYSTEM_TASK) {
        OsBackTrace();
        return LOS_ERRNO_TSK_OPERATE_SYSTEM_TASK;
    }

    if (!OsPreemptable()) { // 不可抢占
        return LOS_ERRNO_TSK_DELAY_IN_LOCK;
    }

    if (tick == 0) {
        return LOS_TaskYield();
    }

    SCHEDULER_LOCK(intSave);
    UINT32 ret = runTask->ops->delay(runTask, OS_SCHED_TICK_TO_CYCLE(tick)); // 调用delay回调
    SCHEDULER_UNLOCK(intSave);
    return ret;
}

LITE_OS_SEC_TEXT_MINOR VOID LOS_Msleep(UINT32 msecs)
{
    UINT32 interval;

    if (msecs == 0) {
        interval = 0;
    } else {
        interval = LOS_MS2Tick(msecs);
        if (interval == 0) {
            interval = 1;
        }
    }
    (VOID)LOS_TaskDelay(interval);
}
```

对于调度算法`HPF`而言, 对应的 `delay` 回调为 `HPFDelay` :

```c
STATIC UINT32 HPFDelay(LosTaskCB *runTask, UINT64 waitTime)
{
    runTask->taskStatus |= OS_TASK_STATUS_DELAY;
    runTask->waitTime = waitTime; // 等待时间
    OsSchedResched(); // 立马让出cpu
    return LOS_OK;
}
```

## task释放cpu

对于 `liteos` 对外提供了接口 `LOS_TaskYield`, 用于让出 `task` 的 `cpu` .

```c
/*!
 * 当前任务释放CPU，并将其移到具有相同优先级的就绪任务队列的末尾. 读懂这个函数 你就彻底搞懂了 yield
 */
LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskYield(VOID)
{
    UINT32 intSave;

    if (OS_INT_ACTIVE) {
        return LOS_ERRNO_TSK_YIELD_IN_INT;
    }

    if (!OsPreemptable()) {
        return LOS_ERRNO_TSK_YIELD_IN_LOCK;
    }
    LosTaskCB *runTask = OsCurrTaskGet();
    if (OS_TID_CHECK_INVALID(runTask->taskID)) {
        return LOS_ERRNO_TSK_ID_INVALID;
    }

    SCHEDULER_LOCK(intSave);
    /* reset timeslice of yielded task */
    runTask->ops->yield(runTask); // 调用yield回调
    SCHEDULER_UNLOCK(intSave);
    return LOS_OK;
}
```

对于 `HPF` 调度算法而言, 对应的 `yield` 回调为 `HPFYield` :

```c
STATIC VOID HPFYield(LosTaskCB *runTask)
{
    SchedRunqueue *rq = OsSchedRunqueue();
    runTask->timeSlice = 0;
    runTask->startTime = OsGetCurrSchedTimeCycle();
    HPFEnqueue(rq, runTask); // 将task放入就绪队列
    OsSchedResched(); // 开始调度别的task
}
```

