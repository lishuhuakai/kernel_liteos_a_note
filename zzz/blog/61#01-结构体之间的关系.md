我这里通过实例来梳理一下 `vnode` , `mount` , `file` 这几者的之间的关系.将这些结构体的关系梳理清楚了,内核文件部分的代码读起来将会非常容易.

下面的代码为了简单起见,我都去掉了错误处理.

## 打开文件

业务进程通过调用 `open` 来打开文件.

```c
/*!
 * 系统调用|打开文件, 正常情况下返回进程的FD值
 */
int SysOpen(const char *path, int oflags, ...)
{
    int procFd = -1;
    mode_t mode = DEFAULT_FILE_MODE; /* 0666: File read-write properties. */
    char *pathRet = NULL;
    procFd = AllocProcessFd(); // 分配进程描述符
    if (oflags & O_CLOEXEC) {
        SetCloexecFlag(procFd);
    }
    if ((unsigned int)oflags & O_DIRECTORY) {//目录标签
        do_opendir(pathRet, oflags);//打开目录
    } else {
		//当fd参数的值是AT_FDCWD,并且path参数是一个相对路径名,fstatat会计算相对于当前目录的path参数.
		//如果path是一个绝对路径,fd参数就会被忽略
        do_open(AT_FDCWD, pathRet, oflags, mode);//打开文件,返回系统描述符
    }
    AssociateSystemFd(procFd, ret);//进程<->系统描述符 关联/绑定
    if (pathRet != NULL) {
        LOS_MemFree(OS_SYS_MEM_ADDR, pathRet);
    }
    return procFd;//返回进程描述符
}
```

此函数中,我们比较关注的是 `do_open` :

```c
/*!
 * 创建一个file结构体
 */
struct file *files_allocate(const struct Vnode *vnode_ptr, int oflags, off_t pos, const void *priv, int minfd)
{
   struct file *filep = NULL;
   // ...
   filep->ops = vnode_ptr->fop; // 这里使用的是vnode的fop
   // ...
}

int fp_open(int dirfd, const char *path, int oflags, mode_t mode)
{
  int accmode;
  struct file *filep = NULL;
  struct Vnode *vnode = NULL;
  struct Vnode *parentVnode = NULL;
  char *fullpath = NULL;

  VnodeHold();
  follow_symlink(dirfd, path, &vnode, &fullpath); // 首先定位到索引节点vnode
  vnode->useCount++;
  VnodeDrop();

  if (oflags & O_TRUNC)
    {
      if (vnode->vop->Truncate)
        {
          ret = vnode->vop->Truncate(vnode, 0); // 将文件截断
        }
    }

  filep = files_allocate(vnode, oflags, 0, NULL, FILE_START_FD); // 分配一个file结构体
  if (filep->ops && filep->ops->open) // 这里的ops实际是vnode->fop
    {
      filep->ops->open(filep);
    }
  // ...
  return filep->fd;
}

int do_open(int dirfd, const char *path, int oflags, mode_t mode)
{
  int ret;
  int fd;
  if ((oflags & (O_WRONLY | O_CREAT)) != 0)
    {
      mode &= ~GetUmask();
      mode &= (S_IRWXU | S_IRWXG | S_IRWXO);
    }
  fd = fp_open(dirfd, path, oflags, mode);
  return fd;
}
```

打开文件最为重要的还是查找文件, `fp_open` 函数通过 `follow_symlink` 来查找文件对应的索引节点.

```c
/*!
 * 通过路径 查找索引节点.路径和节点是 N:1的关系, 硬链接
 */
int VnodeLookupAt(const char *path, struct Vnode **result, uint32_t flags, struct Vnode *orgVnode)
{
    int ret;
    int vnodePathLen;
    char *vnodePath = NULL;
    struct Vnode *startVnode = NULL;
    char *normalizedPath = NULL;

    if (orgVnode != NULL) {
        startVnode = orgVnode;
        normalizedPath = strdup(path);
    } else {
        ret = PreProcess(path, &startVnode, &normalizedPath); // 预处理,规整路径,将相对路径转换为绝对路径
    }

    if (normalizedPath[1] == '\0' && normalizedPath[0] == '/') {
        *result = GetCurrRootVnode();// 啥也不说了,还找啥呀,直接返回根节点
        free(normalizedPath);
        return LOS_OK;
    }
    char *currentDir = normalizedPath;
    struct Vnode *currentVnode = startVnode;

    while (*currentDir != '\0') {
        // 比如查找文件/a/b/c, 那么先找到a对应的vnode,才能找到b对应的vnode,才能到c
        ret = Step(&currentDir, &currentVnode, flags);
        if (currentDir == NULL || *currentDir == '\0') {
            // ... 没找到,错误处理忽略
        } else if (VfsVnodePermissionCheck(currentVnode, EXEC_OP)) { // 校验权限
            // ... 权限校验不通过,错误处理忽略
        }
        if (currentVnode->filePath == NULL) {
            vnodePathLen = currentDir - normalizedPath;
            vnodePath = malloc(vnodePathLen + 1);
            ret = strncpy_s(vnodePath, vnodePathLen + 1, normalizedPath, vnodePathLen);
            currentVnode->filePath = vnodePath; // 记录下路径名称
            currentVnode->filePath[vnodePathLen] = 0;
        }
    }

OUT_FREE_PATH:
    if (normalizedPath) {
        free(normalizedPath);
    }
    return ret;
}

/*!
 * 根据路径查找索引节点
 */
int VnodeLookupFullpath(const char *fullpath, struct Vnode **vnode, uint32_t flags)
{
    return VnodeLookupAt(fullpath, vnode, flags, GetCurrRootVnode());
}
/*!
 * 根据链接查找文件
 */
int follow_symlink(int dirfd, const char *path, struct Vnode **vnode, char **fullpath)
{
  int ret;
  struct Vnode *newvnode = NULL;
  char *pathname = (char *)path;
  char buffer[PATH_MAX] = {0};

  for (int i = 0; i < CONFIG_FS_MAX_LNK_CNT; i++)
    {
      vfs_normalize_pathat(dirfd, pathname, fullpath); // 路径名规整
      VnodeLookupFullpath(*fullpath, &newvnode, 0); // 查找vnode
      if (newvnode->type != VNODE_TYPE_LNK)
      {
          /* The object of fullpath is exist, and is not a symbol link. Return its vnode. */
          *vnode = newvnode;
          return ret;
       }
      /* The object of fullpath is a symbol link. Read its target and find the source file successively. */
      pathname = buffer;
      ret = newvnode->vop->Readlink(newvnode, pathname, PATH_MAX);
    }
  /* Failed to find the source file in CONFIG_FS_MAX_LNK_CNT times. */
  return -ELOOP;
}
```

`follow_symlink` -> `VnodeLookupAt` -> `Step`, `Step` 函数是查找函数的核心,它的实现如下:

```c
/*!
 * 一级一级向下找
 *@param currentDir 当前目录
 *@param currentVnode 当前vnode
 */
static int Step(char **currentDir, struct Vnode **currentVnode, uint32_t flags)
{
    int ret;
    uint8_t len = 0;
    struct Vnode *nextVnode = NULL;
    char *nextDir = NULL;

    if ((*currentVnode)->type != VNODE_TYPE_DIR) { //必须是目录节点
        return -ENOTDIR;
    }
    nextDir = NextName(*currentDir, &len);// 查找下层文件名称

    ret = PathCacheLookup(*currentVnode, nextDir, len, &nextVnode);
    if (ret == LOS_OK) {
        goto STEP_FINISH; // 找到了也不能直接返回
    }

    (*currentVnode)->useCount++;
    if (flags & V_DUMMY) {
        ret = ProcessVirtualVnode(*currentVnode, flags, &nextVnode);
    } else {
        if ((*currentVnode)->vop != NULL && (*currentVnode)->vop->Lookup != NULL) {
            ret = (*currentVnode)->vop->Lookup(*currentVnode, nextDir, len, &nextVnode); // 使用目录的Lookup查找函数
        } else {
            ret = -ENOSYS;
        }
    }
    (*currentVnode)->useCount--;
    if (ret == LOS_OK) {
        (void)PathCacheAlloc((*currentVnode), nextVnode, nextDir, len); // 找到了就构建缓存项,方便后续查找
    }

STEP_FINISH:
    nextVnode = ConvertVnodeIfMounted(nextVnode);
    RefreshLRU(nextVnode);
    *currentDir = nextDir + len;
    if (ret == LOS_OK) {
        *currentVnode = nextVnode;
    }
    return ret;
}
```
`Step` 函数里面有一个比较有意思的事实.比如打开 `/a/b/c`, 而我们已经将 `/dev/sd1` 挂载到了 `/a/b` 目录下, 那么查找的时候,通过 `step` 找到 `/a/b` 的vnode的时候, 实际会返回的是被挂载节点的 `vnode` :

```c
/*!
 * 如果vnode是一个挂载点,那么返回被挂载的vnode
 */
static struct Vnode *ConvertVnodeIfMounted(struct Vnode *vnode)
{
    if ((vnode == NULL) || !(vnode->flag & VNODE_FLAG_MOUNT_ORIGIN)) {
        return vnode;
    }
    return vnode->newMount->vnodeCovered;
}
```

## 读写文件

业务进程调用 `SysRead` 来读取文件:

```c
ssize_t read(int fd, void *buf, size_t nbytes)
{
  	  struct file *filep = NULL;
    // ...
      /* The descriptor is in a valid range to file descriptor... do the
       * read.  First, get the file structure.
       */
      int ret = fs_getfilep(fd, &filep);
      /* Then let file_read do all of the work */
      return file_read(filep, buf, nbytes);
}

/*!
 * 系统调用|读文件:从文件中读取nbytes长度的内容到buf中(用户空间)
 */
ssize_t SysRead(int fd, void *buf, size_t nbytes)
{
    int ret;
    /* Process fd convert to system global fd */
    fd = GetAssociatedSystemFd(fd);//获得关联的系统fd,因为真正的read,write是需要sysFd的
    ret = read(fd, buf, nbytes);
    return ret;
}
```

看一下最简单的 `file_read` :

```c
ssize_t file_read(struct file *filep, void *buf, size_t nbytes)
{
  int ret = -EBADF;
   if (filep->ops && filep->ops->read) // 调用回调函数来进行读取
    {
      /* Yes.. then let it perform the read.  NOTE that for the case of the
       * mountpoint, we depend on the read methods being identical in
       * signature and position in the operations vtable.
       */
      ret = (int)filep->ops->read(filep, (char *)buf, (size_t)nbytes);
    }
  /* Otherwise, return the number of bytes read */
  return ret;
}
```

写文件基本类似, 这里忽略.

## 设备挂载

设备挂载需要调用 `SysMount` 函数:

```c
/*!
 * @brief SysMount	挂载文件系统
 * 挂载是指将一个存储设备挂接到一个已存在的路径上.我们要访问存储设备中的文件,必须将文件所在的分区挂载到一个已存在的路径上,
 * 然后通过这个路径来访问存储设备.如果只有一个存储设备,则可以直接挂载到根目录 / 上,变成根文件系统
 * @param data	特定文件系统的私有数据
 * @param filesystemtype 挂载的文件系统类型	
 * @param mountflags 读写标志位	
 * @param source 已经格式化的块设备名称	
 * @param target 挂载路径,即挂载点	
 */
int SysMount(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags,
             const void *data)
{
    int ret;
    char *sourceRet = NULL;
    char *targetRet = NULL;
    char *dataRet = NULL;
    char fstypeRet[FILESYSTEM_TYPE_MAX + 1] = {0};

    if (target != NULL) {
        UserPathCopy(target, &targetRet); // 将target由用户空间拷贝到内核空间
    }
    if (filesystemtype != NULL) {
        LOS_StrncpyFromUser(fstypeRet, filesystemtype, FILESYSTEM_TYPE_MAX + 1);
        if (strcmp(fstypeRet, "ramfs") && (source != NULL)) {
            UserPathCopy(source, &sourceRet);
        }
    }
    if (data != NULL) {
        UserPathCopy(data, &dataRet);
    }
    ret = mount(sourceRet, targetRet, (filesystemtype ? fstypeRet : NULL), mountflags, dataRet);
    return ret;
}
```

核心函数 `mount` 的实现如下:

```c
/*!
 * 分配一个挂载点
 * 在内核MountAlloc只被VnodeDevInit调用,但真实情况下它还将被系统调用 mount()调用
 * int mount(const char *source, const char *target,
 *          const char *filesystemtype, unsigned long mountflags,
 *          const void *data)
 *  mount见于..\code-2.0-canary\third_party\NuttX\fs\mount\fs_mount.c
 *  vnodeBeCovered: /dev/mmcblk0 
 *@param vnodeBeCovered 要被挂载的节点,比如某个设备
 */
struct Mount *MountAlloc(struct Vnode *vnodeBeCovered, struct MountOps *fsop)
{
    struct Mount *mnt = (struct Mount*)zalloc(sizeof(struct Mount));//申请一个mount结构体内存,小内存分配用 zalloc
    LOS_ListInit(&mnt->activeVnodeList);//初始化激活索引节点链表
    LOS_ListInit(&mnt->vnodeList);//初始化索引节点链表
    mnt->vnodeBeCovered = vnodeBeCovered;//设备将装载到vnodeBeCovered节点上
    vnodeBeCovered->newMount = mnt;//该节点不再是虚拟节点,而作为 设备结点
    mnt->hashseed = (uint32_t)random(); //随机生成哈子种子
    return mnt;
}

int mount(const char *source, const char *target,
          const char *filesystemtype, unsigned long mountflags,
          const void *data)
{
  int ret;
  int errcode = 0;
  struct Mount* mnt = NULL;
  struct Vnode *device = NULL;
  struct Vnode *mountpt_vnode = NULL;
  const struct fsmap_t *fsmap = NULL;
  const struct MountOps *mops = NULL;
  LIST_HEAD *mount_list = NULL;

  /* Find the specified filesystem.  Try the block driver file systems first */
  // 找到指定的文件系统,先尝试块驱动文件系统
  if ((fsmap = mount_findfs(filesystemtype)) == NULL || (fsmap->is_bdfs && !source))
    {
      PRINT_ERR("Failed to find file system %s\n", filesystemtype);
      errcode = -ENODEV;
      goto errout;
    }

  mops = fsmap->fs_mops;
  if (fsmap->is_bdfs && source) // 如果是块设备文件
    {
      /* Find the block driver */
      ret = find_blockdriver(source, mountflags, &device); // 查找对应的驱动
    }

  VnodeHold();
  ret = VnodeLookup(target, &mountpt_vnode, 0); // 查找对应Vnode,挂载点必须要存在

  /* The mount point must be an existed vnode. */
  if (ret != OK)
    {
      PRINT_ERR("Failed to find valid mountpoint %s\n", target);
      errcode = -EINVAL;
      goto errout_with_lock;
    }
  if (mountpt_vnode->flag & VNODE_FLAG_MOUNT_NEW)
    {
      PRINT_ERR("can't mount to %s, already mounted.\n", target); // 不能重复挂载
      errcode = -EINVAL;
      goto errout_with_lock;
    }
  /* Bind the block driver to an instance of the file system.  The file
   * system returns a reference to some opaque, fs-dependent structure
   * that encapsulates this binding.
   */
  mnt = MountAlloc(mountpt_vnode, (struct MountOps*)mops);
  mnt->mountFlags = mountflags;
  mountpt_vnode->useCount++;
  ret = mops->Mount(mnt, device, data);
  mountpt_vnode->useCount--;
  mnt->vnodeBeCovered->flag |= VNODE_FLAG_MOUNT_ORIGIN;
  mnt->vnodeCovered->flag |= VNODE_FLAG_MOUNT_NEW; // 表示已经被挂载了
  mnt->vnodeCovered->filePath = strdup(mountpt_vnode->filePath);
  mnt->vnodeDev = device;
  mnt->ops = mops;
  if (target && (strlen(target) != 0))
    {
      strcpy_s(mnt->pathName, PATH_MAX, target);
    }

  if (source && (strlen(source) != 0))
    {
      strcpy_s(mnt->devName, PATH_MAX, source);
    }

  //* We have it, now populate it with driver specific information. */
  mount_list = GetMountList();
  LOS_ListAdd(mount_list, &mnt->mountList);
  if (!strcmp("/", target))
    {
      ChangeRoot(mnt->vnodeCovered);
    }
  VnodeDrop();
  return OK;
}
```

我们以 `procfs` 文件系统为例子,它的 `Mount` 回调为 `VfsProcfsMount` :

```c
/*!
 * procfs的挂载实现,找个vnode节点挂上去 
 */
int VfsProcfsMount(struct Mount *mnt, struct Vnode *device, const void *data)
{
    struct Vnode *vp = NULL;
    spin_lock_init(&procfsLock);
    procfsInit = true;	//已初始化 /proc 模块
    VnodeAlloc(&g_procfsVops, &vp);//分配一个vnode节点,驱动为g_procfsVops
    struct ProcDirEntry *root = GetProcRootEntry();
    vp->data = root;
    vp->originMount = mnt; //绑定mount
    vp->fop = &g_procfsFops;//指定文件系统
    mnt->data = NULL;
    mnt->vnodeCovered = vp; // 将新分配的节点挂载mnt上
    vp->type = root->type;
    if (vp->type == VNODE_TYPE_DIR) {//目录节点
        vp->mode = S_IFDIR | PROCFS_DEFAULT_MODE;//贴上目录标签
    } else {
        vp->mode = S_IFREG | PROCFS_DEFAULT_MODE;//贴上文件标签
    }
    return LOS_OK;
}
```

## 文件重命名

```c
int do_rename(int oldfd, const char *oldpath, int newfd, const char *newpath)
{
  struct Vnode *old_parent_vnode = NULL;
  struct Vnode *new_parent_vnode = NULL;
  struct Vnode *old_vnode = NULL;
  struct Vnode *new_vnode = NULL;
  char *fulloldpath = NULL;
  char *fullnewpath = NULL;
  char *oldname = NULL;
  char *newname = NULL;

  vfs_normalize_pathat(oldfd, oldpath, &fulloldpath); // 先将名称规整化
  vfs_normalize_pathat(newfd, newpath, &fullnewpath);
  oldname = strrchr(fulloldpath, '/') + 1;
  newname = strrchr(fullnewpath, '/') + 1;
  check_path_invalid(fulloldpath, fullnewpath); // 检查名称的有效性

  VnodeHold();
  ret = VnodeLookup(fulloldpath, &old_vnode, 0); // 查找vnode
  old_parent_vnode = old_vnode->parent; // 得到父索引节点
  ret = VnodeLookup(fullnewpath, &new_vnode, 0);
  if (ret == OK)
    {
      new_parent_vnode = new_vnode->parent;
    }
  else
    {
      new_parent_vnode = new_vnode;
      new_vnode = NULL;
    }
  ret = check_rename_target(old_vnode, old_parent_vnode, new_vnode, new_parent_vnode);
  if (ret != OK)
    {
      goto errout_with_vnode;
    }
  if (old_vnode == new_vnode)
    {
      VnodeDrop();
      free(fulloldpath);
      free(fullnewpath);
      return OK;
    }
  new_parent_vnode->useCount++;
  ret = old_vnode->vop->Rename(old_vnode, new_parent_vnode, oldname, newname); // 调用Rename回调
  new_parent_vnode->useCount--;
  VnodeFree(new_vnode);
  VnodePathCacheFree(old_vnode); // 释放缓存
  old_vnode->filePath = strdup(fullnewpath);
  PathCacheAlloc(new_parent_vnode, old_vnode, newname, strlen(newname));
  old_vnode->parent = new_parent_vnode;
  VnodeDrop();
  free(fulloldpath);
  free(fullnewpath);
  return OK;
}

int rename(const char *oldpath, const char *newpath)
{
  return do_rename(AT_FDCWD, oldpath, AT_FDCWD, newpath);
}
```



## 总结

我们说的文件,一般分为两类, 一类是索引文件(描述数据的数据,元数据), 一种是数据文件(实际的数据).

一定要区分这两个概念,对于普通文件 `x` , 它在文件系统中一定有一个索引文件 `y,用来记录 x 的一些信息,比如访问权限,文件类型等.

索引文件在内核之中用 `Vnode` 来进行描述:

```c
// 对IATTR的修改最终将落到 vnode->vop->Chattr(vnode, attr);
enum VnodeType {//节点类型
    VNODE_TYPE_UNKNOWN,       /* unknown type */ //未知类型
    VNODE_TYPE_REG,           /* regular file */ //vnode代表一个正则文件(普通文件)
    VNODE_TYPE_DIR,           /* directory */    //vnode代表一个目录
    VNODE_TYPE_BLK,           /* block device */ //vnode代表一个块设备
    VNODE_TYPE_CHR,           /* char device */  //vnode代表一个字符设备
    VNODE_TYPE_BCHR,          /* block char mix device *///块和字符设备混合
    VNODE_TYPE_FIFO,          /* pipe */   //vnode代表一个管道
    VNODE_TYPE_LNK,           /* link */   //vnode代表一个符号链接
};
struct Vnode {//vnode并不包含文件名,因为 vnode和文件名是 1:N 的关系
    enum VnodeType type;    /* 节点类型 (文件|目录|链接...) */
    int useCount;           /* 节点引用(链接)数,即有多少文件名指向这个vnode,即上层理解的硬链接数 */   
    uint32_t hash;          /* 节点哈希值 */
    mode_t mode;            /* chmod 文件的读,写,执行权限 */
    LIST_HEAD parentPathCaches;         /* pathCaches point to parents */ //指向父级路径缓存,上面的都是当了爸爸节点
    LIST_HEAD childPathCaches;          /* pathCaches point to children */ //指向子级路径缓存,上面都是当了别人儿子的节点
    struct Vnode *parent;               /* parent vnode */ //父节点
    struct VnodeOps *vop;               /* vnode operations */ //相当于指定操作Vnode方式 (接口实现|驱动程序)
    struct file_operations_vfs *fop;    /* file operations */ //相当于指定文件系统
    void *data;      /* 文件数据block的位置,指向每种具体设备私有的成员,例如 ( drv_data | nfsnode | ....) */
    uint32_t flag;                      /* 节点标签 */
    LIST_ENTRY hashEntry;   /* 通过它挂入哈希表 g_vnodeHashEntrys[i], i:[0,g_vnodeHashMask] */
    LIST_ENTRY actFreeEntry;            /* 通过本节点挂到空闲链表和使用链表上 */
    struct Mount *originMount;          /* fs info about this vnode */ //自己所在的文件系统挂载信息
    // 如果有设备挂载到此文件下(一般为目录),newMount不为空,而且记录了挂载设备以及挂载点的信息
    struct Mount *newMount;             /* fs info about who mount on this vnode */ //其他挂载在这个节点上文件系统信息
};
```

我们知道,存储数据的介质是多种多样的, 比如 `flash`, 磁盘, 内存等, 不同的介质存储文件的方式是天然就存在这差异的. 为了屏蔽掉底层介质的差异,内核抽取出了一个接口, `VnodeOps` 中的接口函数用于操作索引文件(或者称之为描述文件的数据,元数据),不同文件系统的驱动自己实现对应的回调函数即可.

```c
struct VnodeOps {
    int (*Create)(struct Vnode *parent, const char *name, int mode, struct Vnode **vnode);//创建节点
    int (*Lookup)(struct Vnode *parent, const char *name, int len, struct Vnode **vnode);//查询节点
    //Lookup向底层文件系统查找获取inode信息
    int (*Open)(struct Vnode *vnode, int fd, int mode, int flags);//打开节点
    int (*Close)(struct Vnode *vnode);//关闭节点
    int (*Reclaim)(struct Vnode *vnode);//回收节点
    int (*Unlink)(struct Vnode *parent, struct Vnode *vnode, const char *fileName);//取消硬链接
    int (*Rmdir)(struct Vnode *parent, struct Vnode *vnode, const char *dirName);//删除目录节点
    int (*Mkdir)(struct Vnode *parent, const char *dirName, mode_t mode, struct Vnode **vnode);//创建目录节点
    /*
    创建一个目录时,实际做了3件事:在其"父目录文件"中增加一个条目;分配一个inode;再分配一个存储块,
    用来保存当前被创建目录包含的文件与子目录.被创建的"目录文件"中自动生成两个子目录的条目,名称分别是:"."和"..".
    前者与该目录具有相同的inode号码,因此是该目录的一个"硬链接".后者的inode号码就是该目录的父目录的inode号码.
    所以,任何一个目录的"硬链接"总数,总是等于它的子目录总数(含隐藏目录)加2.即每个"子目录文件"中的".."条目,
    加上它自身的"目录文件"中的"."条目,再加上"父目录文件"中的对应该目录的条目.
    */
    int (*Readdir)(struct Vnode *vnode, struct fs_dirent_s *dir);//读目录节点
    int (*Opendir)(struct Vnode *vnode, struct fs_dirent_s *dir);//打开目录节点
    int (*Rewinddir)(struct Vnode *vnode, struct fs_dirent_s *dir);//定位目录节点
    int (*Closedir)(struct Vnode *vnode, struct fs_dirent_s *dir);//关闭目录节点
    int (*Getattr)(struct Vnode *vnode, struct stat *st);//获取节点属性
    int (*Setattr)(struct Vnode *vnode, struct stat *st);//设置节点属性
    int (*Chattr)(struct Vnode *vnode, struct IATTR *attr);//改变节点属性(change attr)
    int (*Rename)(struct Vnode *src, struct Vnode *dstParent, const char *srcName, const char *dstName);//重命名
    int (*Truncate)(struct Vnode *vnode, off_t len);//缩减或扩展大小
    int (*Truncate64)(struct Vnode *vnode, off64_t len);//缩减或扩展大小
    int (*Fscheck)(struct Vnode *vnode, struct fs_dirent_s *dir);//检查功能
    int (*Link)(struct Vnode *src, struct Vnode *dstParent, struct Vnode **dst, const char *dstName);
    int (*Symlink)(struct Vnode *parentVnode, struct Vnode **newVnode, const char *path, const char *target);
    ssize_t (*Readlink)(struct Vnode *vnode, char *buffer, size_t bufLen);
};
```

同样的,在不同的介质下,读写文件的方法也不尽相同,举个例子,在磁盘中,读写文件需要调整磁头,操作磁盘的寄存器, 而内存之中,则不需要,因此,内核同样也抽取出了一个接口 `file_operations_vfs`, 用来屏蔽掉底层的差异:

```c
struct file_operations_vfs {
  int     (*open)(struct file *filep); //打开文件
  int     (*close)(struct file *filep); //关闭文件
  ssize_t (*read)(struct file *filep, char *buffer, size_t buflen); //读文件
  ssize_t (*write)(struct file *filep, const char *buffer, size_t buflen);//写文件
  off_t   (*seek)(struct file *filep, off_t offset, int whence);//寻找,检索 文件
  int     (*ioctl)(struct file *filep, int cmd, unsigned long arg);//对文件的控制命令
  int     (*mmap)(struct file* filep, struct VmMapRegion *region);//内存映射实现<文件/设备 - 线性区的映射>
  /* The two structures need not be common after this point */
#ifndef CONFIG_DISABLE_POLL
  int     (*poll)(struct file *filep, poll_table *fds); //轮询接口
#endif
  int     (*stat)(struct file *filep, struct stat* st); //统计接口
  int     (*fallocate)(struct file* filep, int mode, off_t offset, off_t len);
  int     (*fallocate64)(struct file *filep, int mode, off64_t offset, off64_t len);
  int     (*fsync)(struct file *filep);
  ssize_t (*readpage)(struct file *filep, char *buffer, size_t buflen);
  int     (*unlink)(struct Vnode *vnode);
};
```

大家可能存在疑问,既然索引文件在内核之中有结构体来描述,那么数据文件有对应结构体来描述吗? 一个勉强接近的结构体是 `file` , `file` 用于描述一个打开的文件.

```c
/* This is the underlying representation of an open file.  A file
 * descriptor is an index into an array of such types. The type associates
 * the file descriptor to the file state and to a set of vnode operations.
 */
struct file {
    unsigned int         f_magicnum;  /* file magic number. -- to be deleted */
    int                  f_oflags;    /* Open mode flags | 打开模式,比如读/写 */
    struct Vnode         *f_vnode;    /* Driver interface | 文件对应的索引文件的描述 */
    loff_t               f_pos;       /* File position | 偏移,已经操作到的位置 */
    unsigned long        f_refcount;  /* reference count */
    char                 *f_path;     /* File fullpath | 文件的绝对路径 */
    void                 *f_priv;     /* Per file driver private data | 私有数据 */
    const char           *f_relpath;  /* realpath.  -- to be deleted */
    struct page_mapping  *f_mapping;  /* mapping file to memory */
    void                 *f_dir;      /* DIR struct for iterate the directory if open a directory */
    const struct file_operations_vfs *ops; /* 文件的操作接口 */
    int fd;
};
```



挂载点其实只是操作系统的一个概念而已,它用于将某个设备挂载到某个目录比如 `/a/` 下面,然后业务进程就可以通过 `/a/x` 来访问设备之中的文件 `x` 了. 而原来 `/a/` 目录下的 `b` 文件此时已经无法被访问到了,只有解除了挂载之后才能访问到.

内核使用 `Mount` 来描述挂载点信息:

```c
struct Mount {
    LIST_ENTRY mountList;              /* 通过本节点将Mount挂到全局Mount链表上 */
    const struct MountOps *ops;        /* operations of mount */ //挂载操作函数 
    // 这里的起名是很形象的,Covered有覆盖的意思,vnodeBeCovered -- 被覆盖的vnode
    struct Vnode *vnodeBeCovered;      /* vnode we mounted on */ //要被挂载的节点 即 /bin1/vs/sd 对应的 vnode节点
    // VnodeCovered -- 要覆盖的vnode
    struct Vnode *vnodeCovered;        /* syncer vnode */   //要挂载的节点 即/dev/mmcblk0p0 对应的 vnode节点
    struct Vnode *vnodeDev;            /* dev vnode */
    LIST_HEAD vnodeList;               /* list of vnodes */  //链表表头
    int vnodeSize;                     /* size of vnode list */ //节点数量
    LIST_HEAD activeVnodeList;         /* list of active vnodes */ //激活的节点链表
    int activeVnodeSize;               /* szie of active vnodes list *///激活的节点数量
    void *data;                        /* private data */ //私有数据,可使用这个成员作为一个指向它们自己内部数据的指针
    uint32_t hashseed;                 /* Random seed for vfs hash */ //vfs 哈希随机种子
    unsigned long mountFlags;          /* Flags for mount */ //挂载标签
    char pathName[PATH_MAX];           /* path name of mount point */ //挂载点路径名称  /bin1/vs/sd
    char devName[PATH_MAX];            /* path name of dev point */  //设备名称 /dev/mmcblk0p0
};
```

还是前面提及的那句话,既然要挂载,不同的设备(介质)的挂载方法是有差异的, 因此内核提取出了一个接口 `MountOps`, 不同的设备的驱动自己实现接口即可.

```c
//挂载操作
struct MountOps {
    int (*Mount)(struct Mount *mount, struct Vnode *vnode, const void *data);//挂载
    int (*Unmount)(struct Mount *mount, struct Vnode **blkdriver);//卸载
    int (*Statfs)(struct Mount *mount, struct statfs *sbp);//统计文件系统的信息,如该文件系统类型,总大小,可用大小等信息
};
```

`Mount` 回调里面有一些事情是必须要做的,以 `procfs` 文件系统为例,它的 `Mount` 回调为 `VfsProcfsMount` :

```c
/*!
 * procfs的挂载实现,找个vnode节点挂上去 
 */
int VfsProcfsMount(struct Mount *mnt, struct Vnode *device, const void *data)
{
    struct Vnode *vp = NULL;
    spin_lock_init(&procfsLock);
    procfsInit = true;	//已初始化 /proc 模块
    VnodeAlloc(&g_procfsVops, &vp);//分配一个vnode节点,驱动为g_procfsVops
    struct ProcDirEntry *root = GetProcRootEntry();
    vp->data = root;
    vp->originMount = mnt; //绑定mount
    vp->fop = &g_procfsFops;//指定文件系统
    mnt->data = NULL;
    mnt->vnodeCovered = vp; // 将新分配的节点挂载mnt上
    vp->type = root->type;
    if (vp->type == VNODE_TYPE_DIR) {//目录节点
        vp->mode = S_IFDIR | PROCFS_DEFAULT_MODE;//贴上目录标签
    } else {
        vp->mode = S_IFREG | PROCFS_DEFAULT_MODE;//贴上文件标签
    }
    return LOS_OK;
}
```

+ 创建一个新的 `vnode`, 将其放入 `Mount` 结构体实例 `mnt` 的 `vnodeCovered` 字段,这样,查找挂载点下文件的时候,才能访问到该设备.可以看一下上面查找文件中涉及的 `ConvertVnodeIfMounted` 函数.
+ 一般而言,新创建的 `vnode` 要实现 `VnodeOps` 以及 `file_operations_vfs` 两个接口,用于告诉内核如同操作该设备的索引文件和数据文件.
