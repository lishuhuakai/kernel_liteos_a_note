用户进程在执行的时候,如果访问到了一个没有被映射的地址,或者执行的操作和内存的属性不符合(写了一块只读的内存), 那么 `cpu` 会自动触发 `arm` 的异常处理,具体而言,会跳转到内核 `_osExceptDataAbortHdl` 去执行.

更加具体的流程可以参考之前的文章.

```assembly
@ Description: Data abort exception handler
_osExceptDataAbortHdl:
#ifdef LOSCFG_GDB
#if __LINUX_ARM_ARCH__ >= 7
    GDB_HANDLE OsDataAbortExcHandleEntry
#endif
#else
    SUB     LR, LR, #8                                       @ LR offset to return from this exception: -8.

    SRSFD   #CPSR_SVC_MODE!                                  @ Save pc and cpsr to svc sp, ARMv6 and above support
    MSR     CPSR_c, #(CPSR_INT_DISABLE | CPSR_SVC_MODE)      @ Switch to svc mode, and disable all interrupt
    STMFD   SP!, {R0-R3, R12, LR}
    STMFD   SP, {R13, R14}^
    SUB     SP, SP, #(2 * 4)

    MRC     P15, 0, R2, C6, C0, 0
    MRC     P15, 0, R3, C5, C0, 0
    STMFD   SP!, {R2-R3}                                     @ Save far and fsr
    STMFD   SP!, {R4-R11}

#ifdef LOSCFG_KERNEL_VM
    MOV    R1, SP
    PUSH_FPU_REGS R0

    MOV    R0, #OS_EXCEPT_DATA_ABORT                        @ Set exception ID to OS_EXCEPT_DATA_ABORT.
    BLX    OsArmSharedPageFault
    CMP    R0, #0
    POP_FPU_REGS R0
    BEQ   _osExcPageFaultReturn
#endif

    MOV   R0, #OS_EXCEPT_DATA_ABORT
    B     _osExceptDispatch
#endif
```

内核实际会调用 `OsArmSharedPageFault` 来处理地址异常, 这里的异常包含了访问的地址还未被映射, 以不正确的方式访问了地址等.

```c
/**
 * @brief 共享页错误处理函数
 * @param excType 
 * @param frame 
 * @param far 异常状态寄存器(Fault Status Register -FAR)
 * @param fsr 异常地址寄存器(Fault Address Register -FSR) 
 * @return UINT32 
 */
UINT32 OsArmSharedPageFault(UINT32 excType, ExcContext *frame, UINT32 far, UINT32 fsr)
{
    BOOL instructionFault = FALSE;
    UINT32 pfFlags = 0;
    UINT32 fsrFlag;
    BOOL write = FALSE;
    UINT32 ret;
    if (OsGetSystemStatus() == OS_SYSTEM_EXC_CURR_CPU) {
        return LOS_ERRNO_VM_NOT_FOUND;
    }
#if defined(LOSCFG_KERNEL_SMP) && defined(LOSCFG_DEBUG_VERSION)
    BOOL irqEnable = !(LOS_SpinHeld(&g_taskSpin) && OsSchedIsLock());
    if (irqEnable) {
        ArchIrqEnable();
    } else {
        PrintExcInfo("[ERR][%s] may be held scheduler lock when entering [%s] on cpu [%u]\n",
                     OsCurrTaskGet()->taskName, __FUNCTION__, ArchCurrCpuid());
    }
#else
    ArchIrqEnable();
#endif
    if (excType == OS_EXCEPT_PREFETCH_ABORT) {
        instructionFault = TRUE;
    } else {
        write = !!BIT_GET(fsr, WNR_BIT);
    }

    fsrFlag = ((BIT_GET(fsr, FSR_FLAG_OFFSET_BIT) ? 0b10000 : 0) | BITS_GET(fsr, FSR_BITS_BEGIN_BIT, 0));
    switch (fsrFlag) {
        case 0b00101:
        /* translation fault */
        case 0b00111:
        /* translation fault */
        case 0b01101:
        /* permission fault */
        case 0b01111: {
        /* permission fault */
            BOOL user = (frame->regCPSR & CPSR_MODE_MASK) == CPSR_MODE_USR;
            pfFlags |= write ? VM_MAP_PF_FLAG_WRITE : 0;
            pfFlags |= user ? VM_MAP_PF_FLAG_USER : 0;
            pfFlags |= instructionFault ? VM_MAP_PF_FLAG_INSTRUCTION : 0;
            pfFlags |= VM_MAP_PF_FLAG_NOT_PRESENT;
            OsSigIntLock();
            ret = OsVmPageFaultHandler(far, pfFlags, frame);
            OsSigIntUnlock();
            break;
        }
        default:
            OsArmWriteTlbimvaais(ROUNDDOWN(far, PAGE_SIZE));
            ret = LOS_OK;
            break;
    }
#if defined(LOSCFG_KERNEL_SMP) && defined(LOSCFG_DEBUG_VERSION)
    if (irqEnable) {
        ArchIrqDisable();
    }
#else
    ArchIrqDisable();
#endif
    return ret;
}
```

这个函数的核心是 `OsVmPageFaultHandler` :

```c
/*!
 * 虚拟页错误处理函数
 * @param vaddr 待访问的虚拟地址
 * @param flags 内存的权限(读/写/执行)
 * @param frame 
 * @return STATUS_T 
 */
STATUS_T OsVmPageFaultHandler(VADDR_T vaddr, UINT32 flags, ExcContext *frame)
{
    LosVmSpace *space = LOS_SpaceGet(vaddr);//获取虚拟地址所属空间
    LosVmMapRegion *region = NULL;
    STATUS_T status;
    PADDR_T oldPaddr;
    PADDR_T newPaddr;
    VADDR_T excVaddr = vaddr;
    LosVmPage *newPage = NULL;
    LosVmPgFault vmPgFault = { 0 };
    //地址保护,用户空间不允许跨界访问
    if (((flags & VM_MAP_PF_FLAG_USER) != 0) && (!LOS_IsUserAddress(vaddr))) {
        VM_ERR("user space not allowed to access invalid address: %#x", vaddr);
        return LOS_ERRNO_VM_ACCESS_DENIED;// 拒绝访问
    }
    (VOID)LOS_MuxAcquire(&space->regionMux);
    region = LOS_RegionFind(space, vaddr);//通过虚拟地址找到所在线性区
    status = OsVmRegionPermissionCheck(region, flags); // 检查一下访问属性
    if (status != LOS_OK) {
        status = LOS_ERRNO_VM_ACCESS_DENIED;//拒绝访问
        goto CHECK_FAILED;
    }
    vaddr = ROUNDDOWN(vaddr, PAGE_SIZE);//为啥要向下圆整，因为这一页要重新使用，需找到页面基地址
#ifdef LOSCFG_FS_VFS 
    if (LOS_IsRegionFileValid(region)) {// 是否为文件线性区,也就是访问的地址对应着文件的某处
        vmPgFault.vaddr = vaddr;//虚拟地址
        // 计算出文件读取位置
        vmPgFault.pgoff = ((vaddr - region->range.base) >> PAGE_SHIFT) + region->pgOff;
        vmPgFault.flags = flags;
        vmPgFault.pageKVaddr = NULL;//缺失页初始化没有物理地址
        status = OsDoFileFault(region, &vmPgFault, flags);//缺页处理
        goto DONE;
    }
#endif
	//请求调页:推迟到不能再推迟为止
    newPage = LOS_PhysPageAlloc();//分配一个新的物理页
    newPaddr = VM_PAGE_TO_PHYS(newPage);//获取物理地址
    (VOID)memset_s(OsVmPageToVaddr(newPage), PAGE_SIZE, 0, PAGE_SIZE);//获取虚拟地址 清0
    status = LOS_ArchMmuQuery(&space->archMmu, vaddr, &oldPaddr, NULL);//通过虚拟地址查询老物理地址
    if (status >= 0) { //已经映射过了,@note_thinking 不是缺页吗,怎么会有页的情况? 
        LOS_ArchMmuUnmap(&space->archMmu, vaddr, 1);//解除映射关系
        OsPhysSharePageCopy(oldPaddr, &newPaddr, newPage);//将oldPaddr的数据拷贝到newPage
        if (newPaddr == oldPaddr) {//新老物理地址一致
            LOS_PhysPageFree(newPage);//继续使用旧页释放新页
            newPage = NULL;
        }
		// newPaddr 新的物理地址,将虚拟地址vaddr映射到newPaddr对应的物理地址上
        status = LOS_ArchMmuMap(&space->archMmu, vaddr, newPaddr, 1, region->regionFlags);//重新映射新物理地址
        status = LOS_OK;
        goto DONE;
    } else {
        LOS_AtomicInc(&newPage->refCounts);//引用数自增
        //映射新物理地址,如此下次就不会缺页了
        status = LOS_ArchMmuMap(&space->archMmu, vaddr, newPaddr, 1, region->regionFlags);
    }
    status = LOS_OK;
    goto DONE;
	// ...
DONE:
    (VOID)LOS_MuxRelease(&space->regionMux);
    return status;
}
```

## 非文件页异常

对于非文件页异常,很简单,分配一个新的物理页,并做好映射即可.

## 文件页异常

如果访问的区域对应文件,那么实际会调用 `OsDoFileFault` 来处理访问异常:

```c
 /*!
  * 处理操作文件时产生缺页中断
  */
STATIC STATUS_T OsDoFileFault(LosVmMapRegion *region, LosVmPgFault *vmPgFault, UINT32 flags)
{
    STATUS_T ret;
    if (flags & VM_MAP_PF_FLAG_WRITE) {//写页的时候产生缺页
        if (region->regionFlags & VM_MAP_REGION_FLAG_SHARED) {//共享线性区
            ret = OsDoSharedFault(region, vmPgFault);//写操作时的共享缺页,最复杂,此页上的更改将写入磁盘文件
        } else {//非共享线性区
            //(写时拷贝技术)写操作时的私有缺页,pagecache被复制到私有的任意一个页面上，并在此页面上进行更改,不会直接写入磁盘文件
            ret = OsDoCowFault(region, vmPgFault);
        }
    } else {//读页的时候产生缺页
        //页面读取操作很简单，只需共享页面缓存（节省内存）并进行读权限映射（region->arch_mmu_flags&（~arch_mmu_FLAG_PERM_WRITE））
        ret = OsDoReadFault(region, vmPgFault);
    }
    return ret;
}
```

写文件的时候发生页面异常,而且写的区域是非共享的线性区,执行 `OsDoCowFault` 来进行写时拷贝:

```c
/*!
 * 在私有线性区写入文件时发生缺页的处理
 */
status_t OsDoCowFault(LosVmMapRegion *region, LosVmPgFault *vmPgFault)
{
    STATUS_T ret;
    VOID *kvaddr = NULL;
    PADDR_T oldPaddr = 0;
    PADDR_T newPaddr;
    LosVmPage *oldPage = NULL;
    LosVmPage *newPage = NULL;
    LosVmSpace *space = NULL;

    space = region->space;
    ret = LOS_ArchMmuQuery(&space->archMmu, (VADDR_T)vmPgFault->vaddr, &oldPaddr, NULL);//查询出老物理地址
    if (ret == LOS_OK) {
        oldPage = OsCowUnmapOrg(&space->archMmu, region, vmPgFault);//取消页面映射
    }

    newPage = LOS_PhysPageAlloc();//分配一个新页面
    newPaddr = VM_PAGE_TO_PHYS(newPage);//拿到新的物理地址
    kvaddr = OsVmPageToVaddr(newPage);//拿到新的虚拟地址

    (VOID)LOS_MuxAcquire(&region->unTypeData.rf.vnode->mapping.mux_lock);
    ret = region->unTypeData.rf.vmFOps->fault(region, vmPgFault); // 函数指针 g_commVmOps.OsVmmFileFault
    /**
     * here we get two conditions, 1.this page hasn't mapped or mapped from pagecache,
     * we can take it as a normal file cow map. 2.this page has done file cow map,
     * we can take it as a anonymous cow map.
     */
    if ((oldPaddr == 0) || (LOS_PaddrToKVaddr(oldPaddr) == vmPgFault->pageKVaddr)) {//没有映射或者 已在pagecache有映射
        (VOID)memcpy_s(kvaddr, PAGE_SIZE, vmPgFault->pageKVaddr, PAGE_SIZE);//直接copy到新页
        LOS_AtomicInc(&newPage->refCounts);//引用ref++
        OsCleanPageLocked(LOS_VmPageGet(LOS_PaddrQuery(vmPgFault->pageKVaddr)));//解锁
    } else {
        OsPhysSharePageCopy(oldPaddr, &newPaddr, newPage);//调用之前 oldPaddr肯定不等于newPaddr
        /* use old page free the new one */
        if (newPaddr == oldPaddr) {//注意这里newPaddr可能已经被改变了,参数传入的是 &newPaddr 
            LOS_PhysPageFree(newPage);//释放新页,别浪费的内存,内核使用内存是一分钱当十块用.
            newPage = NULL;
        }
    }
    //把新物理地址映射给缺页的虚拟地址,这样就不会缺页啦
    ret = LOS_ArchMmuMap(&space->archMmu, (VADDR_T)vmPgFault->vaddr, newPaddr, 1, region->regionFlags);
    (VOID)LOS_MuxRelease(&region->unTypeData.rf.vnode->mapping.mux_lock);

    if (oldPage != NULL) {
        OsCleanPageLocked(oldPage);
    }
    return LOS_OK;
}
```

读文件的时候发生异常, 会执行 `OsDoReadFault` :

```c
/*!
 * 读页时发生缺页的处理
 */
STATIC STATUS_T OsDoReadFault(LosVmMapRegion *region, LosVmPgFault *vmPgFault)
{
    status_t ret;
    PADDR_T paddr;
    LosVmPage *page = NULL;
    VADDR_T vaddr = (VADDR_T)vmPgFault->vaddr;
    LosVmSpace *space = region->space;

    ret = LOS_ArchMmuQuery(&space->archMmu, vaddr, NULL, NULL);//查询是否缺页
    if (ret == LOS_OK) {//注意这里时LOS_OK却返回,都OK了说明查到了物理地址,有页了。
        return LOS_OK;//查到了就说明不缺页的，缺页就是因为虚拟地址没有映射到物理地址嘛
    }
    if (region->unTypeData.rf.vmFOps == NULL || region->unTypeData.rf.vmFOps->fault == NULL) {//线性区必须有实现了缺页接口
        VM_ERR("region args invalid, file path: %s", region->unTypeData.rf.vnode->filePath);
        return LOS_ERRNO_VM_INVALID_ARGS;
    }
    (VOID)LOS_MuxAcquire(&region->unTypeData.rf.vnode->mapping.mux_lock);
    ret = region->unTypeData.rf.vmFOps->fault(region, vmPgFault);// 函数指针，执行的是g_commVmOps.OsVmmFileFault
    if (ret == LOS_OK) {
        paddr = LOS_PaddrQuery(vmPgFault->pageKVaddr);//查询物理地址
        page = LOS_VmPageGet(paddr);//获取page
        if (page != NULL) { /* just incase of page null */
            LOS_AtomicInc(&page->refCounts);//ref 自增
            OsCleanPageLocked(page);
        }
        ret = LOS_ArchMmuMap(&space->archMmu, vaddr, paddr, 1,
                             region->regionFlags & (~VM_MAP_REGION_FLAG_PERM_WRITE));//重新映射为非可写

        (VOID)LOS_MuxRelease(&region->unTypeData.rf.vnode->mapping.mux_lock);
        return LOS_OK;
    }
    (VOID)LOS_MuxRelease(&region->unTypeData.rf.vnode->mapping.mux_lock);
    return LOS_ERRNO_VM_NO_MEMORY;
}
```

实际调用的是 `OsVmmFileFault`, 真正从文件之中读取数据到内存里面.

```c
/*!
 * 文件缺页时的处理,先读入磁盘数据，再重新读页数据
 * 被 OsDoReadFault(...),OsDoCowFault(...),OsDoSharedFault(...) 等调用
 */
INT32 OsVmmFileFault(LosVmMapRegion *region, LosVmPgFault *vmf)
{
    INT32 ret;
    VOID *kvaddr = NULL;

    UINT32 intSave;
    bool newCache = false;
    struct Vnode *vnode = NULL;
    struct page_mapping *mapping = NULL;
    LosFilePage *fpage = NULL;
    //文件是否映射到了内存
    if (!LOS_IsRegionFileValid(region) || (region->unTypeData.rf.vnode == NULL) || (vmf == NULL)) {
        VM_ERR("Input param is NULL");
        return LOS_NOK;
    }
    vnode = region->unTypeData.rf.vnode;
    mapping = &vnode->mapping;

    /* get or create a new cache node */
    LOS_SpinLockSave(&mapping->list_lock, &intSave);
    fpage = OsFindGetEntry(mapping, vmf->pgoff);//获取文件页
    TRACE_TRY_CACHE();
    if (fpage != NULL) {//找到了,说明该页已经在页高速缓存中
        TRACE_HIT_CACHE();
        OsPageRefIncLocked(fpage);
    } else {//真的缺页了,页高速缓存中没找到
        fpage = OsPageCacheAlloc(mapping, vmf->pgoff);//分配一个文件页，将数据初始化好，包括vmpage(物理页框)
        newCache = true;//分配了新文件页
    }
    OsSetPageLocked(fpage->vmPage);//对vmpage上锁
    LOS_SpinUnlockRestore(&mapping->list_lock, intSave);
    kvaddr = OsVmPageToVaddr(fpage->vmPage);//获取该页框在内核空间的虚拟地址,因为 page cache本身就是在内核空间,

    /* read file to new page cache */
    if (newCache) {//新cache
        ret = vnode->vop->ReadPage(vnode, kvaddr, fpage->pgoff << PAGE_SHIFT); // 读取文件内容到对应的地址中
        LOS_SpinLockSave(&mapping->list_lock, &intSave);
        OsAddToPageacheLru(fpage, mapping, vmf->pgoff);//将fpage挂入pageCache 和 LruCache
        LOS_SpinUnlockRestore(&mapping->list_lock, intSave);
    }

    LOS_SpinLockSave(&mapping->list_lock, &intSave);
    /* cow fault case no need to save mapinfo */
    if (!((vmf->flags & VM_MAP_PF_FLAG_WRITE) && !(region->regionFlags & VM_MAP_REGION_FLAG_SHARED))) {
        //添加<虚拟地址,文件页>的映射关系,如此进程以后就能通过虚拟地址操作文件页了
        OsAddMapInfo(fpage, &region->space->archMmu, (vaddr_t)vmf->vaddr);
        fpage->flags = region->regionFlags;
    }

    /* share page fault, mark the page dirty */
    //有过写操作或者为共享线性区
    if ((vmf->flags & VM_MAP_PF_FLAG_WRITE) && (region->regionFlags & VM_MAP_REGION_FLAG_SHARED)) {
        OsMarkPageDirty(fpage, region, 0, 0);//标记为脏页,要回写磁盘,内核会在适当的时候回写磁盘
    }
    vmf->pageKVaddr = kvaddr; // 缺陷页记录文件页的虚拟地址
    LOS_SpinUnlockRestore(&mapping->list_lock, intSave);
    return LOS_OK;
}
```

