为了便于阅读, 本文摘抄的代码将去掉错误处理流程,只保留主要的代码.

# 程序加载

内核将会调用 `OsLoadELFFile` 来加载ELF进程.


```c
/*!
 * 加载ELF格式文件
 */
INT32 OsLoadELFFile(ELFLoadInfo *loadInfo)
{
    OsLoadInit(loadInfo);//初始化加载信息
    OsReadEhdr(loadInfo->fileName， &loadInfo->execInfo， TRUE);//读ELF头信息
    OsReadPhdrs(&loadInfo->execInfo， TRUE);//读ELF程序头信息，构建进程映像所需信息。
    OsReadInterpInfo(loadInfo);//读取段 INTERP 解析器信息
    OsSetArgParams(loadInfo， loadInfo->argv， loadInfo->envp);//设置外部参数内容
    OsFlushAspace(loadInfo);//擦除空间
    OsLoadELFSegment(loadInfo);//加载段信息
    OsDeInitLoadInfo(loadInfo);//ELF和.so 加载完成后释放内存
    return LOS_OK;
}
```
这个函数中有一个核心结构体 `ELFLoadInfo`,理解`ELFLoadInfo`是理解鸿蒙加载ELF运行的关键.

```c
typedef struct {//加载ELF信息结构体
    ELFInfo      execInfo; //可执行文件信息
    ELFInfo      interpInfo;//解析器文件信息 lib/libc.so
    const CHAR   *fileName;//文件名称
    CHAR         *execName;//程序名称
    INT32        argc; //参数个数
    INT32        envc; //环境变量个数
    CHAR *const  *argv; //参数数组
    CHAR *const  *envp; //环境变量数组
    UINTPTR      stackTop;//栈底位置，递减满栈下，stackTop是高地址位
    UINTPTR      stackTopMax;//栈最大上限
    UINTPTR      stackBase;//栈顶位置
    UINTPTR      stackParamBase;//栈参数空间，放置启动ELF时的外部参数，大小为 USER_PARAM_BYTE_MAX 4K
    UINT32       stackSize;//栈大小
    INT32        stackProt;//LD_PT_GNU_STACK栈的权限 ，例如(RW)
    UINTPTR      loadAddr; //加载地址
    UINTPTR      elfEntry; //装载点地址 即: _start 函数地址
    UINTPTR      topOfMem; //虚拟空间顶部位置，loadInfo->topOfMem = loadInfo->stackTopMax - sizeof(UINTPTR);
    UINTPTR      oldFiles; //旧空间的文件映像
    LosVmSpace   *newSpace;//新虚拟空间
    LosVmSpace   *oldSpace;//旧虚拟空间
#ifdef LOSCFG_ASLR
    INT32        randomDevFD;
#endif
} ELFLoadInfo;
```

**解读**

* 一个程序要运行需要两个必不可少的硬性条件:
1. 指令在哪里,由 `elfEntry`,它是`.text`的开始位置，直接在 elf头中可以读到;
2. 拿到指令后在哪里运行,即栈在哪里,`ELFLoadInfo`有7个变量在描述栈信息。足以说明栈的重要性。栈的构建对应的是ELF的`GNU_STACK`段，权限必须是 `RW`.
* `interpInfo`对应的是ELF的`INTERP`段，不是所有的ELF都会有`INTERP`段,如下:
```
  INTERP         0x000194 0x00000194 0x00000194 0x00016 0x00016 R   0x1   
      [Requesting program interpreter: /lib/ld-musl-arm.so.1]
```
  这个段的意思就是需要加载动态链接库,`/lib/ld-musl-arm.so.1` 是 `libc.so`的一个软链,具体位置在根文件系统 `/rootfs/lib/libc.so` 位置.
* `argv`，`envc`命令行参数和环境变量内核会专门开辟4K空间,保存在栈底位置,一起保存的还有ELF的辅助向量表`auxVector`.
* `loadAddr` 通过`LOS_MMap`将各 `LOAD`段并做好的虚拟地址和物理地址的映射关系保存在了映射区.
  
* 从代码看对`.bss`区做了匿名映射,见于`OsSetBss()`,不清楚为何内核要区别对待`.bss`区.
* 其余各区做了文件映射.

## 读取ELF头部信息

```c
/*!
 * 获取文件长度信息
 */
STATIC INT32 OsGetFileLength(UINT32 *fileLen, const CHAR *fileName)
{
    struct stat buf;
    INT32 ret;
    stat(fileName, &buf);
    assert(S_ISREG(buf.st_mode) != 0); // 保证是普通文件
    *fileLen = (UINT32)buf.st_size;
    return LOS_OK;
}

/*!
 * 打开ELF文件
 */
STATIC INT32 OsELFOpen(const CHAR *fileName, INT32 oflags)
{
    INT32 ret;
    INT32 procFd;
    procFd = AllocProcessFd();//分配一个文件描述符
    if (oflags & O_CLOEXEC) {
        SetCloexecFlag(procFd);
    }
    open(fileName, oflags);//打开文件
    AssociateSystemFd(procFd, ret);//分配一个系统描述符
    return procFd;
}

/*!
 * 读取文件中的数据,放入buffer之中
 * @param offset 需要读取的数据的起始位置在文件内的偏移位置
 */
STATIC INT32 OsReadELFInfo(INT32 procfd, UINT8 *buffer, size_t readSize, off_t offset)
{
    ssize_t byteNum;
    off_t returnPos;
    INT32 fd = GetAssociatedSystemFd(procfd); // 获得对应的文件描述符
    if (readSize > 0) {
        returnPos = lseek(fd, offset, SEEK_SET); // 将指针移动到偏移的位置
        byteNum = read(fd, buffer, readSize); // 开始读取readSize个字节的数据到buffer之中
    }
    return LOS_OK;
}

/*!
 * 读取ELF头部信息
 * @param fileName 执行文件的名称
 */
STATIC INT32 OsReadEhdr(const CHAR *fileName, ELFInfo *elfInfo, BOOL isExecFile)
{
    INT32 ret;
    OsGetFileLength(&elfInfo->fileLen, fileName); // 获得文件长度,放入elfInfo->fileLen
    ret = OsELFOpen(fileName, O_RDONLY | O_EXECVE | O_CLOEXEC);
    elfInfo->procfd = ret; // 记录下文件描述符
#ifdef LOSCFG_DRIVERS_TZDRIVER
    if (isExecFile) {
        struct file *filep = NULL;
        fs_getfilep(GetAssociatedSystemFd(elfInfo->procfd), &filep);
        OsCurrProcessGet()->execVnode = filep->f_vnode;
    }
#endif
    OsReadELFInfo(elfInfo->procfd, (UINT8 *)&elfInfo->elfEhdr, sizeof(LD_ELF_EHDR), 0);
    OsVerifyELFEhdr(&elfInfo->elfEhdr, elfInfo->fileLen);
    return LOS_OK;
}
```

读取出来的头部的结构如下:

```c
/* 举例: shell elf 
root@5e3abe332c5a:/home/harmony/out/hispark_aries/ipcamera_hispark_aries/bin# readelf -h shell
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x1000
  Start of program headers:          52 (bytes into file)
  Start of section headers:          25268 (bytes into file)
  Flags:                             0x5000200, Version5 EABI, soft-float ABI
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         11
  Size of section headers:           40 (bytes)
  Number of section headers:         27
  Section header string table index: 26
*/
typedef struct {
    //含前16个字节,又可细分成class、data、version等字段,具体含义不用太关心,只需知道前4个字节点包含`ELF`关键字,
    //这样可以判断当前文件是否是ELF格式
    UINT8       elfIdent[LD_EI_NIDENT]; /* Magic number and other info */
    //表示具体ELF类型,可重定位文件/可执行文件/共享库文件
    UINT16      elfType;                /* Object file type */
    //表示cpu架构
    UINT16      elfMachine;             /* Architecture */
    //表示文件版本号
    UINT32      elfVersion;             /* Object file version */
    //对应`Entry point address`,程序入口函数地址,通过进程虚拟地址空间地址表达
    UINT32      elfEntry;               /* Entry point virtual address */
    //对应`Start of program headers`,表示program header table在文件内的偏移位置
    UINT32      elfPhoff;               /* Program header table file offset */
    //对应`Start of section headers`,表示section header table在文件内的偏移位置
    UINT32      elfShoff;               /* Section header table file offset */
    //表示与CPU处理器架构相关的信息
    UINT32      elfFlags;               /* Processor-specific flags */
    //对应`Size of this header`,表示本ELF header自身的长度
    UINT16      elfHeadSize;            /* ELF header size in bytes */
    //对应`Size of program headers`,表示program header table中每个元素的大小
    UINT16      elfPhEntSize;           /* Program header table entry size */
    //对应`Number of program headers`,表示program header table中元素个数
    UINT16      elfPhNum;               /* Program header table entry count */
    //对应`Size of section headers`,表示section header table中每个元素的大小
    UINT16      elfShEntSize;           /* Section header table entry size */
    //对应`Number of section headers`,表示section header table中元素的个数
    UINT16      elfShNum;               /* Section header table entry count */
    //对应`Section header string table index`,表示描述各section字符名称的string table在section header table中的下标
    UINT16      elfShStrIndex;          /* Section header string table index */
} LDElf32Ehdr;
```

## 读取程序头部表信息

`OsReadPhdrs` 用于读取程序头部表(Program Header table)信息, 可能会存在多个程序头.

```c
/*!
 * 读取elf头部信息(Program Header table)
 */
STATIC INT32 OsReadPhdrs(ELFInfo *elfInfo, BOOL isExecFile)
{
    LD_ELF_EHDR *elfEhdr = &elfInfo->elfEhdr;
    UINT32 size;
    INT32 ret;
    assert(elfEhdr->elfPhNum >= 1); // program header table中元素个数不能为空
    assert(elfEhdr->elfPhEntSize == sizeof(LD_ELF_PHDR));
    size = sizeof(LD_ELF_PHDR) * elfEhdr->elfPhNum; // 计算Program header所占用的空间
    elfInfo->elfPhdr = LOS_MemAlloc(m_aucSysMem0, size); // 分配内存
    OsReadELFInfo(elfInfo->procfd, (UINT8 *)elfInfo->elfPhdr, size, elfEhdr->elfPhoff);
    return LOS_OK;
}
```

读取出来的表中数据结构如下:

```c
/* Program Header */
typedef struct {
    //段类型
    UINT32 type;     /* Segment type */
    //此数据成员给出本段内容在文件中的位置,即段内容的开始位置相对于文件开头的偏移量.
    UINT32 offset;   /* Segment file offset */
    //此数据成员给出本段内容的开始位置在进程空间中的虚拟地址.
    UINT32 vAddr;    /* Segment virtual address */
    //此数据成员给出本段内容的开始位置在进程空间中的物理地址.对于目前大多数现代操作系统而言,
    //应用程序中段的物理地址事先是不可知的,所以目前这个成员多数情况下保留不用,或者被操作系统改作它用.
    UINT32 phyAddr;  /* Segment physical address */
    //此数据成员给出本段内容在文件中的大小,单位是字节,可以是0.
    UINT32 fileSize; /* Segment size in file */
    //此数据成员给出本段内容在内容镜像中的大小,单位是字节,可以是0.
    UINT32 memSize;  /* Segment size in memory */
    //此数据成员给出了本段内容的属性.
    UINT32 flags;    /* Segment flags */
    //对于可装载的段来说,其p_vaddr和p_offset的值至少要向内存页面大小对齐.
    UINT32 align;    /* Segment alignment */
} LDElf32Phdr;
```

## 读取段 INTERP 解析器信息

`OsReadInterpInfo` 用于读取 `INTERP` 段, 也就是读取需要加载的解析器.

```c
/*!
 * 读取interp解析器信息
 */
STATIC INT32 OsReadInterpInfo(ELFLoadInfo *loadInfo)
{
    LD_ELF_PHDR *elfPhdr = loadInfo->execInfo.elfPhdr;
    CHAR *elfInterpName = NULL;
    INT32 ret, i;
    for (i = 0; i < loadInfo->execInfo.elfEhdr.elfPhNum; ++i, ++elfPhdr) { // 遍历程序头表
        if (elfPhdr->type != LD_PT_INTERP) { // 保证是INTERP类型
            continue;
        }
        elfInterpName = LOS_MemAlloc(m_aucSysMem0, elfPhdr->fileSize);
		// 将解析器的路径读取出来
        OsReadELFInfo(loadInfo->execInfo.procfd, (UINT8 *)elfInterpName, elfPhdr->fileSize, elfPhdr->offset);
        assert(elfInterpName[elfPhdr->fileSize - 1] == '\0');
        OsReadEhdr("/lib/libc.so", &loadInfo->interpInfo, FALSE); // 加载解析器ELF头部信息
        OsReadPhdrs(&loadInfo->interpInfo, FALSE); // 读取解析器的Program Header table信息
        (VOID)LOS_MemFree(m_aucSysMem0, elfInterpName);
        break;
    }
    return LOS_OK;
}
```

## 设置外部参数内容

`OsSetArgParams` 用于设置好进程的参数信息.

```c
/*!
 * 分配栈区
 */
STATIC UINT32 OsStackAlloc(LosVmSpace *space, VADDR_T vaddr, UINT32 vsize, UINT32 psize, UINT32 regionFlags)
{
    LosVmPage *vmPage = NULL;
    VADDR_T *kvaddr = NULL;
    LosVmMapRegion *region = NULL;
    VADDR_T vaddrTemp;
    PADDR_T paddrTemp;
    UINT32 len;
    (VOID)LOS_MuxAcquire(&space->regionMux);
    kvaddr = LOS_PhysPagesAllocContiguous(psize >> PAGE_SHIFT); //分配物理内存
    region = LOS_RegionAlloc(space, vaddr, vsize, regionFlags | VM_MAP_REGION_FLAG_FIXED, 0); // 分配region
    len = psize;
    vaddrTemp = region->range.base + vsize - psize;
    paddrTemp = LOS_PaddrQuery(kvaddr);
    while (len > 0) {
        vmPage = LOS_VmPageGet(paddrTemp);
        LOS_AtomicInc(&vmPage->refCounts);
        (VOID)LOS_ArchMmuMap(&space->archMmu, vaddrTemp, paddrTemp, 1, region->regionFlags); // 执行MMU的映射操作
        paddrTemp += PAGE_SIZE;
        vaddrTemp += PAGE_SIZE;
        len -= PAGE_SIZE;
    }
    (VOID)LOS_MuxRelease(&space->regionMux);
    return LOS_OK;
}

/*!
 * 解析堆栈部分的属性信息(读/写/执行)
 */
STATIC VOID OsGetStackProt(ELFLoadInfo *loadInfo)
{
    LD_ELF_PHDR *elfPhdrTemp = loadInfo->execInfo.elfPhdr;
    INT32 i;
    for (i = 0; i < loadInfo->execInfo.elfEhdr.elfPhNum; ++i, ++elfPhdrTemp) { //遍历Program Header
        if (elfPhdrTemp->type == LD_PT_GNU_STACK) {
            loadInfo->stackProt = OsGetProt(elfPhdrTemp->flags); // 获取段属性
        }
    }
}

STATIC INT32 OsSetArgParams(ELFLoadInfo *loadInfo, CHAR *const *argv, CHAR *const *envp)
{
    UINT32 vmFlags;
    INT32 ret;
    loadInfo->randomDevFD = open("/dev/urandom", O_RDONLY); // 用于随机分配加载地址
    (VOID)OsGetStackProt(loadInfo);
    assert(((UINT32)loadInfo->stackProt & (PROT_READ | PROT_WRITE)) == (PROT_READ | PROT_WRITE)); //保证可读可写
    loadInfo->stackTopMax = USER_STACK_TOP_MAX - OsGetRndOffset(loadInfo->randomDevFD);//计算栈底位置
    loadInfo->stackBase = loadInfo->stackTopMax - USER_STACK_SIZE;//计算栈基位置
    loadInfo->stackSize = USER_STACK_SIZE; //用户态栈大小
    loadInfo->stackParamBase = loadInfo->stackTopMax - USER_PARAM_BYTE_MAX; //栈参数空间
    vmFlags = OsCvtProtFlagsToRegionFlags(loadInfo->stackProt, MAP_FIXED);
    vmFlags |= VM_MAP_REGION_FLAG_STACK; //标记映射区为栈区
    OsStackAlloc((VOID *)loadInfo->newSpace, loadInfo->stackBase, USER_STACK_SIZE,
                       USER_PARAM_BYTE_MAX, vmFlags);//分配映射区
    loadInfo->topOfMem = loadInfo->stackTopMax - sizeof(UINTPTR);
    loadInfo->argc = OsGetParamNum(argv);
    loadInfo->envc = OsGetParamNum(envp);
    OsCopyParams(loadInfo, 1, (CHAR *const *)&loadInfo->fileName);
    loadInfo->execName = (CHAR *)loadInfo->topOfMem;
    OsCopyParams(loadInfo, loadInfo->envc, envp);
    OsCopyParams(loadInfo, loadInfo->argc, argv);
    loadInfo->argStart = loadInfo->topOfMem;
    return LOS_OK;
}
```

## 擦除空间

`OsFlushAspace` 用于切换运行空间:

```c
LITE_OS_SEC_TEXT LosVmSpace *OsExecProcessVmSpaceReplace(LosVmSpace *newSpace, UINTPTR stackBase, INT32 randomDevFD)
{
    LosProcessCB *processCB = OsCurrProcessGet();
    LosTaskCB *runTask = OsCurrTaskGet();
    OsProcessThreadGroupDestroy();
    OsTaskCBRecycleToFree();
    LosVmSpace *oldSpace = processCB->vmSpace;
    processCB->vmSpace = newSpace;
    processCB->vmSpace->heapBase += OsGetRndOffset(randomDevFD);
    processCB->vmSpace->heapNow = processCB->vmSpace->heapBase;
    processCB->vmSpace->mapBase += OsGetRndOffset(randomDevFD);
    processCB->vmSpace->mapSize = stackBase - processCB->vmSpace->mapBase;
    runTask->archMmu = (UINTPTR)&processCB->vmSpace->archMmu;
    LOS_ArchMmuContextSwitch((LosArchMmu *)runTask->archMmu); // 切换mmu上下文
    return oldSpace;
}

STATIC VOID OsFlushAspace(ELFLoadInfo *loadInfo)
{
    loadInfo->oldSpace = OsExecProcessVmSpaceReplace(loadInfo->newSpace, loadInfo->stackBase, loadInfo->randomDevFD);
}
```



## 加载段信息

`OsLoadELFSegment` 加载各个段的信息, 然后做好映射.

在这里, 先科普一下程序头中各个段的类型:  

| 类型            | 值         | 说明                                                         |
| --------------- | ---------- | ------------------------------------------------------------ |
| LD_PT_NULL      | 0          | 表明本程序头是未使用的,本程序头内的其它成员值均无意义.具有此种类型的程序头应该被忽略. |
| LD_PT_LOAD      | 1          | 此类型表明本程序头指向一个**可装载的段**.段的内容会被从文件中拷贝到内存中.如前所述,段在文件中的大小是p_filesz,在内存中的大小是p_memsz.如果p_memsz大于p_filesz,在内存中多出的存储空间应填0补充,也就是说,段在内存中可以比在文件中占用空间更大；而相反,p_filesz永远不应该比p_memsz大,因为这样的话,内存中就将无法完整地映射段的内容.在程序头表中,所有PT_LOAD类型的程序头按照p_vaddr的值做升序排列. |
| LD_PT_DYNAMIC   | 2          | 描述了动态加载段                                             |
| LD_PT_INTERP    | 3          | 本段指向了一个以"null"结尾的字符串,这个字符串是一个ELF解析器的路径.这种段类型只对可执行程序有意义,当它出现在共享目标文件中时,是一个无意义的多余项.在一个ELF文件中它最多只能出现一次,而且必须出现在其它可装载段的表项之前 |
| LD_PT_NOTE      | 4          | 本段指向了一个以"null"结尾的字符串,这个字符串包含一些附加的信息 |
| LD_PT_SHLIB     | 5          | 该段类型是保留的,而且未定义语法.UNIX System V系统上的应用程序不会包含这种表项 |
| LD_PT_PHDR      | 6          | 此类型的程序头如果存在的话,它表明的是其自身所在的程序头表在文件或内存中的位置和大小.这样的段在文件中可以不存在,只有当所在程序头表所覆盖的段只是整个程序的一部分时,才会出现一次这种表项,而且这种表项一定出现在其它可装载段的表项之前. |
| LD_PT_GNU_STACK | 0x6474e551 | 堆栈                                                         |

具体的实现如下:

```c
/*!
 * 执行映射操作
 * @param fd 文件对应的句柄
 * @param addr 虚拟地址(要映射的区域的起始地址)
 * @param mapSize 要映射的区域的大小
 * @param prot 区域属性信息
 */
STATIC UINTPTR OsDoMmapFile(INT32 fd, UINTPTR addr, const LD_ELF_PHDR *elfPhdr, UINT32 prot, UINT32 flags,
                            UINT32 mapSize)
{
    UINTPTR mapAddr;
    UINT32 size;
	// offset是此数据成员在文件中的位置,即段内容的开始位置相对于文件开头的偏移量
	// vAddr给出了段内容开始位置在进程空间中的虚拟地址
    UINT32 offset = elfPhdr->offset - ROUNDOFFSET(elfPhdr->vAddr, PAGE_SIZE);
    addr = ROUNDDOWN(addr, PAGE_SIZE);
    if (mapSize != 0) {
        mapAddr = (UINTPTR)LOS_MMap(addr, mapSize, prot, flags, fd, offset >> PAGE_SHIFT);
    } else {
        size = elfPhdr->memSize + ROUNDOFFSET(elfPhdr->vAddr, PAGE_SIZE);
        if (size == 0) {
            return addr;
        }
        mapAddr = (UINTPTR)LOS_MMap(addr, size, prot, flags, fd, offset >> PAGE_SHIFT); // 执行映射操作
    }
    assert(!LOS_IsUserAddress((VADDR_T)mapAddr)); 
    return mapAddr;
}
/*!
 * 设置bss段
 */
STATIC INT32 OsSetBss(const LD_ELF_PHDR *elfPhdr, INT32 fd, UINTPTR bssStart, UINT32 bssEnd, UINT32 elfProt)
{
    UINTPTR bssStartPageAlign, bssEndPageAlign;
    UINTPTR mapBase;
    UINT32 bssMapSize;
    INT32 stackFlags;
    bssStartPageAlign = ROUNDUP(bssStart, PAGE_SIZE);
    bssEndPageAlign = ROUNDUP(bssEnd, PAGE_SIZE);
    LOS_UserMemClear((VOID *)bssStart, PAGE_SIZE - ROUNDOFFSET(bssStart, PAGE_SIZE)); // 将内存清零
    bssMapSize = bssEndPageAlign - bssStartPageAlign;
    if (bssMapSize > 0) {
        stackFlags = MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS;
        // 执行映射操作
        mapBase = (UINTPTR)LOS_MMap(bssStartPageAlign, bssMapSize, elfProt, stackFlags, -1, 0);
        assert(LOS_IsUserAddress((VADDR_T)mapBase));
    }
    return LOS_OK;
}

/*!
 * 映射elf文件
 */
STATIC INT32 OsMmapELFFile(INT32 procfd, const LD_ELF_PHDR *elfPhdr, const LD_ELF_EHDR *elfEhdr, UINTPTR *elfLoadAddr,
                           UINT32 mapSize, UINTPTR *loadBase)
{
    const LD_ELF_PHDR *elfPhdrTemp = elfPhdr;
    UINTPTR vAddr, mapAddr, bssStart;
    UINT32 bssEnd, elfProt, elfFlags;
    INT32 ret, i;
    INT32 fd = GetAssociatedSystemFd(procfd);

    for (i = 0; i < elfEhdr->elfPhNum; ++i, ++elfPhdrTemp) { // 遍历Program Header表
        // 要根据Program Header来加载进程
        if (elfPhdrTemp->type != LD_PT_LOAD) { // 必须是可装载的段
            continue;
        }
        elfProt = OsGetProt(elfPhdrTemp->flags); // 段属性
        elfFlags = MAP_PRIVATE | MAP_FIXED;
        vAddr = elfPhdrTemp->vAddr; //获取虚拟地址
        if ((vAddr == 0) && (*loadBase == 0)) {
            elfFlags &= ~MAP_FIXED;
        }
		// 对加载的内存执行映射操作
        mapAddr = OsDoMmapFile(fd, (vAddr + *loadBase), elfPhdrTemp, elfProt, elfFlags, mapSize);
        assert(LOS_IsUserAddress((VADDR_T)mapAddr)); // 保证地址在用户空间
#ifdef LOSCFG_DRIVERS_TZDRIVER
        if ((elfPhdrTemp->flags & PF_R) && (elfPhdrTemp->flags & PF_X) && 
            !(elfPhdrTemp->flags & PF_W)) { // 可读,可执行但是不可写
            SetVmmRegionCodeStart(vAddr + *loadBase, elfPhdrTemp->memSize);
        }
#endif
        mapSize = 0;
        if (*elfLoadAddr == 0) {
            *elfLoadAddr = mapAddr + ROUNDOFFSET(vAddr, PAGE_SIZE);
        }
        if ((*loadBase == 0) && (elfEhdr->elfType == LD_ET_DYN)) { // 如果是动态库
            *loadBase = mapAddr;
        }
		// 如果memSize大于fileSize,在内存中多出的存储空间应填0补充,也就是说,段在内存中可以比在文件中占用空间更大
        if ((elfPhdrTemp->memSize > elfPhdrTemp->fileSize) && 
            (elfPhdrTemp->flags & PF_W)) { // 段可写
            bssStart = mapAddr + ROUNDOFFSET(vAddr, PAGE_SIZE) + elfPhdrTemp->fileSize;
            bssEnd = mapAddr + ROUNDOFFSET(vAddr, PAGE_SIZE) + elfPhdrTemp->memSize;
            OsSetBss(elfPhdrTemp, fd, bssStart, bssEnd, elfProt);
        }
    }
    return LOS_OK;
}

/*!
 * 加载解析器
 * @param interpMapBase 加载基址
 */
STATIC INT32 OsLoadInterpBinary(ELFLoadInfo *loadInfo, UINTPTR *interpMapBase)
{
    UINTPTR loadBase = 0;
    UINT32 mapSize;
    INT32 ret;
	// 为Program Header 分配空间
    OsGetAllocSize(loadInfo->interpInfo.elfPhdr, loadInfo->interpInfo.elfEhdr.elfPhNum);

	// 执行映射操作
    OsMmapELFFile(loadInfo->interpInfo.procfd, loadInfo->interpInfo.elfPhdr, &loadInfo->interpInfo.elfEhdr,
                        interpMapBase, mapSize, &loadBase);
    return ret;
}

/*!
 * 加载segment(段)
 */
STATIC INT32 OsLoadELFSegment(ELFLoadInfo *loadInfo)
{
    LD_ELF_PHDR *elfPhdrTemp = loadInfo->execInfo.elfPhdr; // Program Header table
    UINTPTR loadBase = 0;
    UINTPTR interpMapBase = 0;
    UINT32 mapSize = 0;
    INT32 ret;
    loadInfo->loadAddr = 0;
    if (loadInfo->execInfo.elfEhdr.elfType == LD_ET_DYN) { // 动态库
        loadBase = EXEC_MMAP_BASE + OsGetRndOffset(loadInfo->randomDevFD); // 随机分配一个加载基址
        // 计算要映射的段的大小
        mapSize = OsGetAllocSize(elfPhdrTemp, loadInfo->execInfo.elfEhdr.elfPhNum);
    }
	// 映射elf文件
    // loadInfo->loadAddr 加载地址
    OsMmapELFFile(loadInfo->execInfo.procfd, loadInfo->execInfo.elfPhdr, &loadInfo->execInfo.elfEhdr,
                        &loadInfo->loadAddr, mapSize, &loadBase);
    OsELFClose(loadInfo->execInfo.procfd); // 关闭文件描述符
    loadInfo->execInfo.procfd = INVALID_FD;
 
    if (loadInfo->interpInfo.procfd != INVALID_FD) {
        OsLoadInterpBinary(loadInfo, &interpMapBase); // 加载解析器
        OsELFClose(loadInfo->interpInfo.procfd);
        loadInfo->interpInfo.procfd = INVALID_FD;
        // 这里的elfEntry指向装载点地址 即: _start 函数地址
        loadInfo->elfEntry = loadInfo->interpInfo.elfEhdr.elfEntry + interpMapBase;
        // 执行文件的装载点地址?
        loadInfo->execInfo.elfEhdr.elfEntry = loadInfo->execInfo.elfEhdr.elfEntry + loadBase;
    } else {
        loadInfo->elfEntry = loadInfo->execInfo.elfEhdr.elfEntry;
    }
    OsMakeArgsStack(loadInfo, interpMapBase);
    assert(LOS_IsUserAddress((VADDR_T)loadInfo->stackTop));
    return LOS_OK;
}
```

# 程序运行

程序加载完成之后,将会执行 `OsExecve` 函数,正式地跑用户代码.

```c
/*!
 * 执行用户态任务, entry为入口函数 ,其中 创建好task,task上下文 等待调度真正执行, sp:栈指针 mapBase:栈底 mapSize:栈大小
 */
LITE_OS_SEC_TEXT UINT32 OsExecStart(const TSK_ENTRY_FUNC entry, UINTPTR sp, UINTPTR mapBase, UINT32 mapSize)
{
    UINT32 intSave;
    assert(entry == NULL);
    if ((sp == 0) || (LOS_Align(sp, LOSCFG_STACK_POINT_ALIGN_SIZE) != sp)) {//对齐
        return LOS_NOK;
    }
	// 注意 sp此时指向栈底,栈底地址要大于栈顶
    assert(!((mapBase == 0) || (mapSize == 0) || (sp <= mapBase) || (sp > (mapBase + mapSize)))); 
    LosTaskCB *taskCB = OsCurrTaskGet();//获取当前任务
    SCHEDULER_LOCK(intSave);//拿自旋锁
    taskCB->userMapBase = mapBase;//用户态栈顶位置
    taskCB->userMapSize = mapSize;//用户态栈
    taskCB->taskEntry = (TSK_ENTRY_FUNC)entry;//任务的入口函数
	//初始化内核态栈
    TaskContext *taskContext = (TaskContext *)OsTaskStackInit(taskCB->taskID, taskCB->stackSize,
                                                              (VOID *)taskCB->topOfStack, FALSE);
    //初始化用户栈,将内核栈中上下文的 context->R[0] = sp ,context->sp = sp
    OsUserTaskStackInit(taskContext, (UINTPTR)taskCB->taskEntry, sp);
    //这样做的目的是将用户栈SP保存到内核栈中,
    SCHEDULER_UNLOCK(intSave);//解锁
    return LOS_OK;
}

/*!
 * 运行ELF
 */
STATIC INT32 OsExecve(const ELFLoadInfo *loadInfo)
{
    if ((loadInfo == NULL) || (loadInfo->elfEntry == 0)) {
        return LOS_NOK;
    }
	//任务运行的两个硬性要求:1.提供入口指令 2.运行栈空间.
    // loadInfo->elfEntry是要程序运行的第一条指令
    // loadInfo->stackTop是堆栈栈底
    // loadInfo->stackBase是堆栈栈基
    return OsExecStart((TSK_ENTRY_FUNC)(loadInfo->elfEntry), (UINTPTR)loadInfo->stackTop,
                       loadInfo->stackBase, loadInfo->stackSize);
}
```

## 内核栈初始化

```c
/*!
 * 内核态任务运行栈初始化
 *@param stackSize 堆栈大小
 *@param topStack 栈顶的指针
 */
LITE_OS_SEC_TEXT_INIT VOID *OsTaskStackInit(UINT32 taskID, UINT32 stackSize, VOID *topStack, BOOL initFlag)
{
    if (initFlag == TRUE) {
        OsStackInit(topStack, stackSize);
    }
	// TaskContext放在栈的底部
    //上下文存放在栈的底部
    TaskContext *taskContext = (TaskContext *)(((UINTPTR)topStack + stackSize) - sizeof(TaskContext));
    /* initialize the task context */ 
    //初始化任务上下文
    taskContext->PC = (UINTPTR)OsTaskEntry; //内核态任务有统一的入口地址
	// LR记录的一般是返回地址
    taskContext->LR = (UINTPTR)OsTaskExit;  /* LR should be kept, to distinguish it's THUMB or ARM instruction */
    taskContext->R0 = taskID;               /* R0 */
#ifdef LOSCFG_THUMB
    taskContext->regCPSR = PSR_MODE_SVC_THUMB; /* CPSR (Enable IRQ and FIQ interrupts, THUMNB-mode) */
#else //用于设置CPSR寄存器
    taskContext->regCPSR = PSR_MODE_SVC_ARM;   /* CPSR (Enable IRQ and FIQ interrupts, ARM-mode) */
#endif

#if !defined(LOSCFG_ARCH_FPU_DISABLE)
    /* 0xAAA0000000000000LL : float reg initialed magic word */
    for (UINT32 index = 0; index < FP_REGS_NUM; index++) {
        taskContext->D[index] = 0xAAA0000000000000LL + index; /* D0 - D31 */
    }
    taskContext->regFPSCR = 0;
    taskContext->regFPEXC = FP_EN;
#endif
    return (VOID *)taskContext;
}
```

## 用户栈初始化

```c
/*!
 * 用户态运行栈初始化,此时上下文还在内核区
 */
LITE_OS_SEC_TEXT_INIT VOID OsUserTaskStackInit(TaskContext *context, UINTPTR taskEntry, UINTPTR stack)
{
    LOS_ASSERT(context != NULL);
#ifdef LOSCFG_THUMB
    context->regCPSR = PSR_MODE_USR_THUMB;
#else
    context->regCPSR = PSR_MODE_USR_ARM;
#endif
    context->R0 = stack;//将用户态栈指针保存到上下文R0处
    context->USP = TRUNCATE(stack, LOSCFG_STACK_POINT_ALIGN_SIZE);//改变上下文的SP值,指向用户栈空间
    context->ULR = 0;//保存子程序返回地址 例如 a call b ,在b中保存 a地址
    context->PC = (UINTPTR)taskEntry;//入口函数,由外部传入,由上层应用指定,固然每个都不一样
}
```





